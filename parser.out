Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    THEN

Grammar

Rule 0     S' -> program
Rule 1     program -> stmt_list SEMICOLON
Rule 2     stmt_list -> stmt_list SEMICOLON stmt
Rule 3     stmt_list -> stmt
Rule 4     stmt -> assignment
Rule 5     stmt -> read
Rule 6     stmt -> write
Rule 7     stmt -> declaration
Rule 8     stmt -> construct_while
Rule 9     stmt -> construct_repeat
Rule 10    stmt -> construct_if
Rule 11    stmt -> block
Rule 12    block -> BEGIN stmt_list END
Rule 13    construct_while -> WHILE LPAR l_expr RPAR DO block
Rule 14    construct_repeat -> REPEAT stmt_list UNTIL LPAR l_expr RPAR
Rule 15    construct_if -> IF LPAR l_expr RPAR stmt construct_else
Rule 16    construct_else -> <empty>
Rule 17    construct_else -> ELSE stmt
Rule 18    l_expr -> a_expr oprel a_expr
Rule 19    oprel -> LT
Rule 20    oprel -> GT
Rule 21    oprel -> LEQ
Rule 22    oprel -> GEQ
Rule 23    assignment -> ID arr_idx ASSIGN a_expr
Rule 24    assignment -> ID ASSIGN a_expr
Rule 25    declaration -> datatype ID arr_size
Rule 26    arr_size -> LBRACK a_expr RBRACK
Rule 27    arr_size -> <empty>
Rule 28    datatype -> DT_INT
Rule 29    datatype -> DT_FLOAT
Rule 30    a_expr -> a_expr ADD a_term
Rule 31    a_expr -> a_expr SUB a_term
Rule 32    a_expr -> a_term
Rule 33    a_term -> a_term DIV a_fact
Rule 34    a_term -> a_term MUL a_fact
Rule 35    a_term -> a_fact
Rule 36    a_fact -> varref
Rule 37    a_fact -> INTEGER
Rule 38    a_fact -> FLOAT
Rule 39    a_fact -> LPAR a_expr RPAR
Rule 40    a_fact -> SUB a_expr
Rule 41    a_fact -> LITERAL_STR
Rule 42    varref -> ID
Rule 43    varref -> ID arr_idx
Rule 44    arr_idx -> LBRACK a_expr RBRACK
Rule 45    read -> READ varlist
Rule 46    write -> WRITE expr_list
Rule 47    varlist -> varlist COMMA varref
Rule 48    varlist -> varref
Rule 49    expr_list -> expr_list COMMA a_expr
Rule 50    expr_list -> a_expr

Terminals, with rules where they appear

ADD                  : 30
ASSIGN               : 23 24
BEGIN                : 12
COMMA                : 47 49
DIV                  : 33
DO                   : 13
DT_FLOAT             : 29
DT_INT               : 28
ELSE                 : 17
END                  : 12
FLOAT                : 38
GEQ                  : 22
GT                   : 20
ID                   : 23 24 25 42 43
IF                   : 15
INTEGER              : 37
LBRACK               : 26 44
LEQ                  : 21
LITERAL_STR          : 41
LPAR                 : 13 14 15 39
LT                   : 19
MUL                  : 34
RBRACK               : 26 44
READ                 : 45
REPEAT               : 14
RPAR                 : 13 14 15 39
SEMICOLON            : 1 2
SUB                  : 31 40
THEN                 : 
UNTIL                : 14
WHILE                : 13
WRITE                : 46
error                : 

Nonterminals, with rules where they appear

a_expr               : 18 18 23 24 26 30 31 39 40 44 49 50
a_fact               : 33 34 35
a_term               : 30 31 32 33 34
arr_idx              : 23 43
arr_size             : 25
assignment           : 4
block                : 11 13
construct_else       : 15
construct_if         : 10
construct_repeat     : 9
construct_while      : 8
datatype             : 25
declaration          : 7
expr_list            : 46 49
l_expr               : 13 14 15
oprel                : 18
program              : 0
read                 : 5
stmt                 : 2 3 15 17
stmt_list            : 1 2 12 14
varlist              : 45 47
varref               : 36 47 48
write                : 6

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . stmt_list SEMICOLON
    (2) stmt_list -> . stmt_list SEMICOLON stmt
    (3) stmt_list -> . stmt
    (4) stmt -> . assignment
    (5) stmt -> . read
    (6) stmt -> . write
    (7) stmt -> . declaration
    (8) stmt -> . construct_while
    (9) stmt -> . construct_repeat
    (10) stmt -> . construct_if
    (11) stmt -> . block
    (23) assignment -> . ID arr_idx ASSIGN a_expr
    (24) assignment -> . ID ASSIGN a_expr
    (45) read -> . READ varlist
    (46) write -> . WRITE expr_list
    (25) declaration -> . datatype ID arr_size
    (13) construct_while -> . WHILE LPAR l_expr RPAR DO block
    (14) construct_repeat -> . REPEAT stmt_list UNTIL LPAR l_expr RPAR
    (15) construct_if -> . IF LPAR l_expr RPAR stmt construct_else
    (12) block -> . BEGIN stmt_list END
    (28) datatype -> . DT_INT
    (29) datatype -> . DT_FLOAT

    ID              shift and go to state 12
    READ            shift and go to state 13
    WRITE           shift and go to state 14
    WHILE           shift and go to state 16
    REPEAT          shift and go to state 17
    IF              shift and go to state 18
    BEGIN           shift and go to state 19
    DT_INT          shift and go to state 20
    DT_FLOAT        shift and go to state 21

    program                        shift and go to state 1
    stmt_list                      shift and go to state 2
    stmt                           shift and go to state 3
    assignment                     shift and go to state 4
    read                           shift and go to state 5
    write                          shift and go to state 6
    declaration                    shift and go to state 7
    construct_while                shift and go to state 8
    construct_repeat               shift and go to state 9
    construct_if                   shift and go to state 10
    block                          shift and go to state 11
    datatype                       shift and go to state 15

state 1

    (0) S' -> program .



state 2

    (1) program -> stmt_list . SEMICOLON
    (2) stmt_list -> stmt_list . SEMICOLON stmt

    SEMICOLON       shift and go to state 22


state 3

    (3) stmt_list -> stmt .

    SEMICOLON       reduce using rule 3 (stmt_list -> stmt .)
    UNTIL           reduce using rule 3 (stmt_list -> stmt .)
    END             reduce using rule 3 (stmt_list -> stmt .)


state 4

    (4) stmt -> assignment .

    SEMICOLON       reduce using rule 4 (stmt -> assignment .)
    UNTIL           reduce using rule 4 (stmt -> assignment .)
    END             reduce using rule 4 (stmt -> assignment .)
    ELSE            reduce using rule 4 (stmt -> assignment .)


state 5

    (5) stmt -> read .

    SEMICOLON       reduce using rule 5 (stmt -> read .)
    UNTIL           reduce using rule 5 (stmt -> read .)
    END             reduce using rule 5 (stmt -> read .)
    ELSE            reduce using rule 5 (stmt -> read .)


state 6

    (6) stmt -> write .

    SEMICOLON       reduce using rule 6 (stmt -> write .)
    UNTIL           reduce using rule 6 (stmt -> write .)
    END             reduce using rule 6 (stmt -> write .)
    ELSE            reduce using rule 6 (stmt -> write .)


state 7

    (7) stmt -> declaration .

    SEMICOLON       reduce using rule 7 (stmt -> declaration .)
    UNTIL           reduce using rule 7 (stmt -> declaration .)
    END             reduce using rule 7 (stmt -> declaration .)
    ELSE            reduce using rule 7 (stmt -> declaration .)


state 8

    (8) stmt -> construct_while .

    SEMICOLON       reduce using rule 8 (stmt -> construct_while .)
    UNTIL           reduce using rule 8 (stmt -> construct_while .)
    END             reduce using rule 8 (stmt -> construct_while .)
    ELSE            reduce using rule 8 (stmt -> construct_while .)


state 9

    (9) stmt -> construct_repeat .

    SEMICOLON       reduce using rule 9 (stmt -> construct_repeat .)
    UNTIL           reduce using rule 9 (stmt -> construct_repeat .)
    END             reduce using rule 9 (stmt -> construct_repeat .)
    ELSE            reduce using rule 9 (stmt -> construct_repeat .)


state 10

    (10) stmt -> construct_if .

    SEMICOLON       reduce using rule 10 (stmt -> construct_if .)
    UNTIL           reduce using rule 10 (stmt -> construct_if .)
    END             reduce using rule 10 (stmt -> construct_if .)
    ELSE            reduce using rule 10 (stmt -> construct_if .)


state 11

    (11) stmt -> block .

    SEMICOLON       reduce using rule 11 (stmt -> block .)
    UNTIL           reduce using rule 11 (stmt -> block .)
    END             reduce using rule 11 (stmt -> block .)
    ELSE            reduce using rule 11 (stmt -> block .)


state 12

    (23) assignment -> ID . arr_idx ASSIGN a_expr
    (24) assignment -> ID . ASSIGN a_expr
    (44) arr_idx -> . LBRACK a_expr RBRACK

    ASSIGN          shift and go to state 24
    LBRACK          shift and go to state 25

    arr_idx                        shift and go to state 23

state 13

    (45) read -> READ . varlist
    (47) varlist -> . varlist COMMA varref
    (48) varlist -> . varref
    (42) varref -> . ID
    (43) varref -> . ID arr_idx

    ID              shift and go to state 28

    varlist                        shift and go to state 26
    varref                         shift and go to state 27

state 14

    (46) write -> WRITE . expr_list
    (49) expr_list -> . expr_list COMMA a_expr
    (50) expr_list -> . a_expr
    (30) a_expr -> . a_expr ADD a_term
    (31) a_expr -> . a_expr SUB a_term
    (32) a_expr -> . a_term
    (33) a_term -> . a_term DIV a_fact
    (34) a_term -> . a_term MUL a_fact
    (35) a_term -> . a_fact
    (36) a_fact -> . varref
    (37) a_fact -> . INTEGER
    (38) a_fact -> . FLOAT
    (39) a_fact -> . LPAR a_expr RPAR
    (40) a_fact -> . SUB a_expr
    (41) a_fact -> . LITERAL_STR
    (42) varref -> . ID
    (43) varref -> . ID arr_idx

    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36
    LPAR            shift and go to state 37
    SUB             shift and go to state 32
    LITERAL_STR     shift and go to state 38
    ID              shift and go to state 28

    expr_list                      shift and go to state 29
    a_expr                         shift and go to state 30
    a_term                         shift and go to state 31
    a_fact                         shift and go to state 33
    varref                         shift and go to state 34

state 15

    (25) declaration -> datatype . ID arr_size

    ID              shift and go to state 39


state 16

    (13) construct_while -> WHILE . LPAR l_expr RPAR DO block

    LPAR            shift and go to state 40


state 17

    (14) construct_repeat -> REPEAT . stmt_list UNTIL LPAR l_expr RPAR
    (2) stmt_list -> . stmt_list SEMICOLON stmt
    (3) stmt_list -> . stmt
    (4) stmt -> . assignment
    (5) stmt -> . read
    (6) stmt -> . write
    (7) stmt -> . declaration
    (8) stmt -> . construct_while
    (9) stmt -> . construct_repeat
    (10) stmt -> . construct_if
    (11) stmt -> . block
    (23) assignment -> . ID arr_idx ASSIGN a_expr
    (24) assignment -> . ID ASSIGN a_expr
    (45) read -> . READ varlist
    (46) write -> . WRITE expr_list
    (25) declaration -> . datatype ID arr_size
    (13) construct_while -> . WHILE LPAR l_expr RPAR DO block
    (14) construct_repeat -> . REPEAT stmt_list UNTIL LPAR l_expr RPAR
    (15) construct_if -> . IF LPAR l_expr RPAR stmt construct_else
    (12) block -> . BEGIN stmt_list END
    (28) datatype -> . DT_INT
    (29) datatype -> . DT_FLOAT

    ID              shift and go to state 12
    READ            shift and go to state 13
    WRITE           shift and go to state 14
    WHILE           shift and go to state 16
    REPEAT          shift and go to state 17
    IF              shift and go to state 18
    BEGIN           shift and go to state 19
    DT_INT          shift and go to state 20
    DT_FLOAT        shift and go to state 21

    stmt_list                      shift and go to state 41
    stmt                           shift and go to state 3
    assignment                     shift and go to state 4
    read                           shift and go to state 5
    write                          shift and go to state 6
    declaration                    shift and go to state 7
    construct_while                shift and go to state 8
    construct_repeat               shift and go to state 9
    construct_if                   shift and go to state 10
    block                          shift and go to state 11
    datatype                       shift and go to state 15

state 18

    (15) construct_if -> IF . LPAR l_expr RPAR stmt construct_else

    LPAR            shift and go to state 42


state 19

    (12) block -> BEGIN . stmt_list END
    (2) stmt_list -> . stmt_list SEMICOLON stmt
    (3) stmt_list -> . stmt
    (4) stmt -> . assignment
    (5) stmt -> . read
    (6) stmt -> . write
    (7) stmt -> . declaration
    (8) stmt -> . construct_while
    (9) stmt -> . construct_repeat
    (10) stmt -> . construct_if
    (11) stmt -> . block
    (23) assignment -> . ID arr_idx ASSIGN a_expr
    (24) assignment -> . ID ASSIGN a_expr
    (45) read -> . READ varlist
    (46) write -> . WRITE expr_list
    (25) declaration -> . datatype ID arr_size
    (13) construct_while -> . WHILE LPAR l_expr RPAR DO block
    (14) construct_repeat -> . REPEAT stmt_list UNTIL LPAR l_expr RPAR
    (15) construct_if -> . IF LPAR l_expr RPAR stmt construct_else
    (12) block -> . BEGIN stmt_list END
    (28) datatype -> . DT_INT
    (29) datatype -> . DT_FLOAT

    ID              shift and go to state 12
    READ            shift and go to state 13
    WRITE           shift and go to state 14
    WHILE           shift and go to state 16
    REPEAT          shift and go to state 17
    IF              shift and go to state 18
    BEGIN           shift and go to state 19
    DT_INT          shift and go to state 20
    DT_FLOAT        shift and go to state 21

    stmt_list                      shift and go to state 43
    stmt                           shift and go to state 3
    assignment                     shift and go to state 4
    read                           shift and go to state 5
    write                          shift and go to state 6
    declaration                    shift and go to state 7
    construct_while                shift and go to state 8
    construct_repeat               shift and go to state 9
    construct_if                   shift and go to state 10
    block                          shift and go to state 11
    datatype                       shift and go to state 15

state 20

    (28) datatype -> DT_INT .

    ID              reduce using rule 28 (datatype -> DT_INT .)


state 21

    (29) datatype -> DT_FLOAT .

    ID              reduce using rule 29 (datatype -> DT_FLOAT .)


state 22

    (1) program -> stmt_list SEMICOLON .
    (2) stmt_list -> stmt_list SEMICOLON . stmt
    (4) stmt -> . assignment
    (5) stmt -> . read
    (6) stmt -> . write
    (7) stmt -> . declaration
    (8) stmt -> . construct_while
    (9) stmt -> . construct_repeat
    (10) stmt -> . construct_if
    (11) stmt -> . block
    (23) assignment -> . ID arr_idx ASSIGN a_expr
    (24) assignment -> . ID ASSIGN a_expr
    (45) read -> . READ varlist
    (46) write -> . WRITE expr_list
    (25) declaration -> . datatype ID arr_size
    (13) construct_while -> . WHILE LPAR l_expr RPAR DO block
    (14) construct_repeat -> . REPEAT stmt_list UNTIL LPAR l_expr RPAR
    (15) construct_if -> . IF LPAR l_expr RPAR stmt construct_else
    (12) block -> . BEGIN stmt_list END
    (28) datatype -> . DT_INT
    (29) datatype -> . DT_FLOAT

    $end            reduce using rule 1 (program -> stmt_list SEMICOLON .)
    ID              shift and go to state 12
    READ            shift and go to state 13
    WRITE           shift and go to state 14
    WHILE           shift and go to state 16
    REPEAT          shift and go to state 17
    IF              shift and go to state 18
    BEGIN           shift and go to state 19
    DT_INT          shift and go to state 20
    DT_FLOAT        shift and go to state 21

    stmt                           shift and go to state 44
    assignment                     shift and go to state 4
    read                           shift and go to state 5
    write                          shift and go to state 6
    declaration                    shift and go to state 7
    construct_while                shift and go to state 8
    construct_repeat               shift and go to state 9
    construct_if                   shift and go to state 10
    block                          shift and go to state 11
    datatype                       shift and go to state 15

state 23

    (23) assignment -> ID arr_idx . ASSIGN a_expr

    ASSIGN          shift and go to state 45


state 24

    (24) assignment -> ID ASSIGN . a_expr
    (30) a_expr -> . a_expr ADD a_term
    (31) a_expr -> . a_expr SUB a_term
    (32) a_expr -> . a_term
    (33) a_term -> . a_term DIV a_fact
    (34) a_term -> . a_term MUL a_fact
    (35) a_term -> . a_fact
    (36) a_fact -> . varref
    (37) a_fact -> . INTEGER
    (38) a_fact -> . FLOAT
    (39) a_fact -> . LPAR a_expr RPAR
    (40) a_fact -> . SUB a_expr
    (41) a_fact -> . LITERAL_STR
    (42) varref -> . ID
    (43) varref -> . ID arr_idx

    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36
    LPAR            shift and go to state 37
    SUB             shift and go to state 32
    LITERAL_STR     shift and go to state 38
    ID              shift and go to state 28

    a_expr                         shift and go to state 46
    a_term                         shift and go to state 31
    a_fact                         shift and go to state 33
    varref                         shift and go to state 34

state 25

    (44) arr_idx -> LBRACK . a_expr RBRACK
    (30) a_expr -> . a_expr ADD a_term
    (31) a_expr -> . a_expr SUB a_term
    (32) a_expr -> . a_term
    (33) a_term -> . a_term DIV a_fact
    (34) a_term -> . a_term MUL a_fact
    (35) a_term -> . a_fact
    (36) a_fact -> . varref
    (37) a_fact -> . INTEGER
    (38) a_fact -> . FLOAT
    (39) a_fact -> . LPAR a_expr RPAR
    (40) a_fact -> . SUB a_expr
    (41) a_fact -> . LITERAL_STR
    (42) varref -> . ID
    (43) varref -> . ID arr_idx

    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36
    LPAR            shift and go to state 37
    SUB             shift and go to state 32
    LITERAL_STR     shift and go to state 38
    ID              shift and go to state 28

    a_expr                         shift and go to state 47
    a_term                         shift and go to state 31
    a_fact                         shift and go to state 33
    varref                         shift and go to state 34

state 26

    (45) read -> READ varlist .
    (47) varlist -> varlist . COMMA varref

    SEMICOLON       reduce using rule 45 (read -> READ varlist .)
    UNTIL           reduce using rule 45 (read -> READ varlist .)
    END             reduce using rule 45 (read -> READ varlist .)
    ELSE            reduce using rule 45 (read -> READ varlist .)
    COMMA           shift and go to state 48


state 27

    (48) varlist -> varref .

    COMMA           reduce using rule 48 (varlist -> varref .)
    SEMICOLON       reduce using rule 48 (varlist -> varref .)
    UNTIL           reduce using rule 48 (varlist -> varref .)
    END             reduce using rule 48 (varlist -> varref .)
    ELSE            reduce using rule 48 (varlist -> varref .)


state 28

    (42) varref -> ID .
    (43) varref -> ID . arr_idx
    (44) arr_idx -> . LBRACK a_expr RBRACK

    COMMA           reduce using rule 42 (varref -> ID .)
    SEMICOLON       reduce using rule 42 (varref -> ID .)
    UNTIL           reduce using rule 42 (varref -> ID .)
    END             reduce using rule 42 (varref -> ID .)
    ELSE            reduce using rule 42 (varref -> ID .)
    DIV             reduce using rule 42 (varref -> ID .)
    MUL             reduce using rule 42 (varref -> ID .)
    ADD             reduce using rule 42 (varref -> ID .)
    SUB             reduce using rule 42 (varref -> ID .)
    RBRACK          reduce using rule 42 (varref -> ID .)
    RPAR            reduce using rule 42 (varref -> ID .)
    LT              reduce using rule 42 (varref -> ID .)
    GT              reduce using rule 42 (varref -> ID .)
    LEQ             reduce using rule 42 (varref -> ID .)
    GEQ             reduce using rule 42 (varref -> ID .)
    LBRACK          shift and go to state 25

    arr_idx                        shift and go to state 49

state 29

    (46) write -> WRITE expr_list .
    (49) expr_list -> expr_list . COMMA a_expr

    SEMICOLON       reduce using rule 46 (write -> WRITE expr_list .)
    UNTIL           reduce using rule 46 (write -> WRITE expr_list .)
    END             reduce using rule 46 (write -> WRITE expr_list .)
    ELSE            reduce using rule 46 (write -> WRITE expr_list .)
    COMMA           shift and go to state 50


state 30

    (50) expr_list -> a_expr .
    (30) a_expr -> a_expr . ADD a_term
    (31) a_expr -> a_expr . SUB a_term

    COMMA           reduce using rule 50 (expr_list -> a_expr .)
    SEMICOLON       reduce using rule 50 (expr_list -> a_expr .)
    UNTIL           reduce using rule 50 (expr_list -> a_expr .)
    END             reduce using rule 50 (expr_list -> a_expr .)
    ELSE            reduce using rule 50 (expr_list -> a_expr .)
    ADD             shift and go to state 51
    SUB             shift and go to state 52


state 31

    (32) a_expr -> a_term .
    (33) a_term -> a_term . DIV a_fact
    (34) a_term -> a_term . MUL a_fact

  ! shift/reduce conflict for DIV resolved as shift
  ! shift/reduce conflict for MUL resolved as shift
    ADD             reduce using rule 32 (a_expr -> a_term .)
    SUB             reduce using rule 32 (a_expr -> a_term .)
    COMMA           reduce using rule 32 (a_expr -> a_term .)
    SEMICOLON       reduce using rule 32 (a_expr -> a_term .)
    UNTIL           reduce using rule 32 (a_expr -> a_term .)
    END             reduce using rule 32 (a_expr -> a_term .)
    ELSE            reduce using rule 32 (a_expr -> a_term .)
    RBRACK          reduce using rule 32 (a_expr -> a_term .)
    RPAR            reduce using rule 32 (a_expr -> a_term .)
    LT              reduce using rule 32 (a_expr -> a_term .)
    GT              reduce using rule 32 (a_expr -> a_term .)
    LEQ             reduce using rule 32 (a_expr -> a_term .)
    GEQ             reduce using rule 32 (a_expr -> a_term .)
    DIV             shift and go to state 53
    MUL             shift and go to state 54

  ! DIV             [ reduce using rule 32 (a_expr -> a_term .) ]
  ! MUL             [ reduce using rule 32 (a_expr -> a_term .) ]


state 32

    (40) a_fact -> SUB . a_expr
    (30) a_expr -> . a_expr ADD a_term
    (31) a_expr -> . a_expr SUB a_term
    (32) a_expr -> . a_term
    (33) a_term -> . a_term DIV a_fact
    (34) a_term -> . a_term MUL a_fact
    (35) a_term -> . a_fact
    (36) a_fact -> . varref
    (37) a_fact -> . INTEGER
    (38) a_fact -> . FLOAT
    (39) a_fact -> . LPAR a_expr RPAR
    (40) a_fact -> . SUB a_expr
    (41) a_fact -> . LITERAL_STR
    (42) varref -> . ID
    (43) varref -> . ID arr_idx

    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36
    LPAR            shift and go to state 37
    SUB             shift and go to state 32
    LITERAL_STR     shift and go to state 38
    ID              shift and go to state 28

    a_expr                         shift and go to state 55
    a_term                         shift and go to state 31
    a_fact                         shift and go to state 33
    varref                         shift and go to state 34

state 33

    (35) a_term -> a_fact .

    DIV             reduce using rule 35 (a_term -> a_fact .)
    MUL             reduce using rule 35 (a_term -> a_fact .)
    ADD             reduce using rule 35 (a_term -> a_fact .)
    SUB             reduce using rule 35 (a_term -> a_fact .)
    COMMA           reduce using rule 35 (a_term -> a_fact .)
    SEMICOLON       reduce using rule 35 (a_term -> a_fact .)
    UNTIL           reduce using rule 35 (a_term -> a_fact .)
    END             reduce using rule 35 (a_term -> a_fact .)
    ELSE            reduce using rule 35 (a_term -> a_fact .)
    RBRACK          reduce using rule 35 (a_term -> a_fact .)
    RPAR            reduce using rule 35 (a_term -> a_fact .)
    LT              reduce using rule 35 (a_term -> a_fact .)
    GT              reduce using rule 35 (a_term -> a_fact .)
    LEQ             reduce using rule 35 (a_term -> a_fact .)
    GEQ             reduce using rule 35 (a_term -> a_fact .)


state 34

    (36) a_fact -> varref .

    DIV             reduce using rule 36 (a_fact -> varref .)
    MUL             reduce using rule 36 (a_fact -> varref .)
    ADD             reduce using rule 36 (a_fact -> varref .)
    SUB             reduce using rule 36 (a_fact -> varref .)
    COMMA           reduce using rule 36 (a_fact -> varref .)
    SEMICOLON       reduce using rule 36 (a_fact -> varref .)
    UNTIL           reduce using rule 36 (a_fact -> varref .)
    END             reduce using rule 36 (a_fact -> varref .)
    ELSE            reduce using rule 36 (a_fact -> varref .)
    RBRACK          reduce using rule 36 (a_fact -> varref .)
    RPAR            reduce using rule 36 (a_fact -> varref .)
    LT              reduce using rule 36 (a_fact -> varref .)
    GT              reduce using rule 36 (a_fact -> varref .)
    LEQ             reduce using rule 36 (a_fact -> varref .)
    GEQ             reduce using rule 36 (a_fact -> varref .)


state 35

    (37) a_fact -> INTEGER .

    DIV             reduce using rule 37 (a_fact -> INTEGER .)
    MUL             reduce using rule 37 (a_fact -> INTEGER .)
    ADD             reduce using rule 37 (a_fact -> INTEGER .)
    SUB             reduce using rule 37 (a_fact -> INTEGER .)
    COMMA           reduce using rule 37 (a_fact -> INTEGER .)
    SEMICOLON       reduce using rule 37 (a_fact -> INTEGER .)
    UNTIL           reduce using rule 37 (a_fact -> INTEGER .)
    END             reduce using rule 37 (a_fact -> INTEGER .)
    ELSE            reduce using rule 37 (a_fact -> INTEGER .)
    RBRACK          reduce using rule 37 (a_fact -> INTEGER .)
    RPAR            reduce using rule 37 (a_fact -> INTEGER .)
    LT              reduce using rule 37 (a_fact -> INTEGER .)
    GT              reduce using rule 37 (a_fact -> INTEGER .)
    LEQ             reduce using rule 37 (a_fact -> INTEGER .)
    GEQ             reduce using rule 37 (a_fact -> INTEGER .)


state 36

    (38) a_fact -> FLOAT .

    DIV             reduce using rule 38 (a_fact -> FLOAT .)
    MUL             reduce using rule 38 (a_fact -> FLOAT .)
    ADD             reduce using rule 38 (a_fact -> FLOAT .)
    SUB             reduce using rule 38 (a_fact -> FLOAT .)
    COMMA           reduce using rule 38 (a_fact -> FLOAT .)
    SEMICOLON       reduce using rule 38 (a_fact -> FLOAT .)
    UNTIL           reduce using rule 38 (a_fact -> FLOAT .)
    END             reduce using rule 38 (a_fact -> FLOAT .)
    ELSE            reduce using rule 38 (a_fact -> FLOAT .)
    RBRACK          reduce using rule 38 (a_fact -> FLOAT .)
    RPAR            reduce using rule 38 (a_fact -> FLOAT .)
    LT              reduce using rule 38 (a_fact -> FLOAT .)
    GT              reduce using rule 38 (a_fact -> FLOAT .)
    LEQ             reduce using rule 38 (a_fact -> FLOAT .)
    GEQ             reduce using rule 38 (a_fact -> FLOAT .)


state 37

    (39) a_fact -> LPAR . a_expr RPAR
    (30) a_expr -> . a_expr ADD a_term
    (31) a_expr -> . a_expr SUB a_term
    (32) a_expr -> . a_term
    (33) a_term -> . a_term DIV a_fact
    (34) a_term -> . a_term MUL a_fact
    (35) a_term -> . a_fact
    (36) a_fact -> . varref
    (37) a_fact -> . INTEGER
    (38) a_fact -> . FLOAT
    (39) a_fact -> . LPAR a_expr RPAR
    (40) a_fact -> . SUB a_expr
    (41) a_fact -> . LITERAL_STR
    (42) varref -> . ID
    (43) varref -> . ID arr_idx

    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36
    LPAR            shift and go to state 37
    SUB             shift and go to state 32
    LITERAL_STR     shift and go to state 38
    ID              shift and go to state 28

    a_expr                         shift and go to state 56
    a_term                         shift and go to state 31
    a_fact                         shift and go to state 33
    varref                         shift and go to state 34

state 38

    (41) a_fact -> LITERAL_STR .

    DIV             reduce using rule 41 (a_fact -> LITERAL_STR .)
    MUL             reduce using rule 41 (a_fact -> LITERAL_STR .)
    ADD             reduce using rule 41 (a_fact -> LITERAL_STR .)
    SUB             reduce using rule 41 (a_fact -> LITERAL_STR .)
    COMMA           reduce using rule 41 (a_fact -> LITERAL_STR .)
    SEMICOLON       reduce using rule 41 (a_fact -> LITERAL_STR .)
    UNTIL           reduce using rule 41 (a_fact -> LITERAL_STR .)
    END             reduce using rule 41 (a_fact -> LITERAL_STR .)
    ELSE            reduce using rule 41 (a_fact -> LITERAL_STR .)
    RBRACK          reduce using rule 41 (a_fact -> LITERAL_STR .)
    RPAR            reduce using rule 41 (a_fact -> LITERAL_STR .)
    LT              reduce using rule 41 (a_fact -> LITERAL_STR .)
    GT              reduce using rule 41 (a_fact -> LITERAL_STR .)
    LEQ             reduce using rule 41 (a_fact -> LITERAL_STR .)
    GEQ             reduce using rule 41 (a_fact -> LITERAL_STR .)


state 39

    (25) declaration -> datatype ID . arr_size
    (26) arr_size -> . LBRACK a_expr RBRACK
    (27) arr_size -> .

    LBRACK          shift and go to state 58
    SEMICOLON       reduce using rule 27 (arr_size -> .)
    UNTIL           reduce using rule 27 (arr_size -> .)
    END             reduce using rule 27 (arr_size -> .)
    ELSE            reduce using rule 27 (arr_size -> .)

    arr_size                       shift and go to state 57

state 40

    (13) construct_while -> WHILE LPAR . l_expr RPAR DO block
    (18) l_expr -> . a_expr oprel a_expr
    (30) a_expr -> . a_expr ADD a_term
    (31) a_expr -> . a_expr SUB a_term
    (32) a_expr -> . a_term
    (33) a_term -> . a_term DIV a_fact
    (34) a_term -> . a_term MUL a_fact
    (35) a_term -> . a_fact
    (36) a_fact -> . varref
    (37) a_fact -> . INTEGER
    (38) a_fact -> . FLOAT
    (39) a_fact -> . LPAR a_expr RPAR
    (40) a_fact -> . SUB a_expr
    (41) a_fact -> . LITERAL_STR
    (42) varref -> . ID
    (43) varref -> . ID arr_idx

    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36
    LPAR            shift and go to state 37
    SUB             shift and go to state 32
    LITERAL_STR     shift and go to state 38
    ID              shift and go to state 28

    l_expr                         shift and go to state 59
    a_expr                         shift and go to state 60
    a_term                         shift and go to state 31
    a_fact                         shift and go to state 33
    varref                         shift and go to state 34

state 41

    (14) construct_repeat -> REPEAT stmt_list . UNTIL LPAR l_expr RPAR
    (2) stmt_list -> stmt_list . SEMICOLON stmt

    UNTIL           shift and go to state 61
    SEMICOLON       shift and go to state 62


state 42

    (15) construct_if -> IF LPAR . l_expr RPAR stmt construct_else
    (18) l_expr -> . a_expr oprel a_expr
    (30) a_expr -> . a_expr ADD a_term
    (31) a_expr -> . a_expr SUB a_term
    (32) a_expr -> . a_term
    (33) a_term -> . a_term DIV a_fact
    (34) a_term -> . a_term MUL a_fact
    (35) a_term -> . a_fact
    (36) a_fact -> . varref
    (37) a_fact -> . INTEGER
    (38) a_fact -> . FLOAT
    (39) a_fact -> . LPAR a_expr RPAR
    (40) a_fact -> . SUB a_expr
    (41) a_fact -> . LITERAL_STR
    (42) varref -> . ID
    (43) varref -> . ID arr_idx

    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36
    LPAR            shift and go to state 37
    SUB             shift and go to state 32
    LITERAL_STR     shift and go to state 38
    ID              shift and go to state 28

    l_expr                         shift and go to state 63
    a_expr                         shift and go to state 60
    a_term                         shift and go to state 31
    a_fact                         shift and go to state 33
    varref                         shift and go to state 34

state 43

    (12) block -> BEGIN stmt_list . END
    (2) stmt_list -> stmt_list . SEMICOLON stmt

    END             shift and go to state 64
    SEMICOLON       shift and go to state 62


state 44

    (2) stmt_list -> stmt_list SEMICOLON stmt .

    SEMICOLON       reduce using rule 2 (stmt_list -> stmt_list SEMICOLON stmt .)
    UNTIL           reduce using rule 2 (stmt_list -> stmt_list SEMICOLON stmt .)
    END             reduce using rule 2 (stmt_list -> stmt_list SEMICOLON stmt .)


state 45

    (23) assignment -> ID arr_idx ASSIGN . a_expr
    (30) a_expr -> . a_expr ADD a_term
    (31) a_expr -> . a_expr SUB a_term
    (32) a_expr -> . a_term
    (33) a_term -> . a_term DIV a_fact
    (34) a_term -> . a_term MUL a_fact
    (35) a_term -> . a_fact
    (36) a_fact -> . varref
    (37) a_fact -> . INTEGER
    (38) a_fact -> . FLOAT
    (39) a_fact -> . LPAR a_expr RPAR
    (40) a_fact -> . SUB a_expr
    (41) a_fact -> . LITERAL_STR
    (42) varref -> . ID
    (43) varref -> . ID arr_idx

    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36
    LPAR            shift and go to state 37
    SUB             shift and go to state 32
    LITERAL_STR     shift and go to state 38
    ID              shift and go to state 28

    a_expr                         shift and go to state 65
    a_term                         shift and go to state 31
    a_fact                         shift and go to state 33
    varref                         shift and go to state 34

state 46

    (24) assignment -> ID ASSIGN a_expr .
    (30) a_expr -> a_expr . ADD a_term
    (31) a_expr -> a_expr . SUB a_term

    SEMICOLON       reduce using rule 24 (assignment -> ID ASSIGN a_expr .)
    UNTIL           reduce using rule 24 (assignment -> ID ASSIGN a_expr .)
    END             reduce using rule 24 (assignment -> ID ASSIGN a_expr .)
    ELSE            reduce using rule 24 (assignment -> ID ASSIGN a_expr .)
    ADD             shift and go to state 51
    SUB             shift and go to state 52


state 47

    (44) arr_idx -> LBRACK a_expr . RBRACK
    (30) a_expr -> a_expr . ADD a_term
    (31) a_expr -> a_expr . SUB a_term

    RBRACK          shift and go to state 66
    ADD             shift and go to state 51
    SUB             shift and go to state 52


state 48

    (47) varlist -> varlist COMMA . varref
    (42) varref -> . ID
    (43) varref -> . ID arr_idx

    ID              shift and go to state 28

    varref                         shift and go to state 67

state 49

    (43) varref -> ID arr_idx .

    COMMA           reduce using rule 43 (varref -> ID arr_idx .)
    SEMICOLON       reduce using rule 43 (varref -> ID arr_idx .)
    UNTIL           reduce using rule 43 (varref -> ID arr_idx .)
    END             reduce using rule 43 (varref -> ID arr_idx .)
    ELSE            reduce using rule 43 (varref -> ID arr_idx .)
    DIV             reduce using rule 43 (varref -> ID arr_idx .)
    MUL             reduce using rule 43 (varref -> ID arr_idx .)
    ADD             reduce using rule 43 (varref -> ID arr_idx .)
    SUB             reduce using rule 43 (varref -> ID arr_idx .)
    RBRACK          reduce using rule 43 (varref -> ID arr_idx .)
    RPAR            reduce using rule 43 (varref -> ID arr_idx .)
    LT              reduce using rule 43 (varref -> ID arr_idx .)
    GT              reduce using rule 43 (varref -> ID arr_idx .)
    LEQ             reduce using rule 43 (varref -> ID arr_idx .)
    GEQ             reduce using rule 43 (varref -> ID arr_idx .)


state 50

    (49) expr_list -> expr_list COMMA . a_expr
    (30) a_expr -> . a_expr ADD a_term
    (31) a_expr -> . a_expr SUB a_term
    (32) a_expr -> . a_term
    (33) a_term -> . a_term DIV a_fact
    (34) a_term -> . a_term MUL a_fact
    (35) a_term -> . a_fact
    (36) a_fact -> . varref
    (37) a_fact -> . INTEGER
    (38) a_fact -> . FLOAT
    (39) a_fact -> . LPAR a_expr RPAR
    (40) a_fact -> . SUB a_expr
    (41) a_fact -> . LITERAL_STR
    (42) varref -> . ID
    (43) varref -> . ID arr_idx

    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36
    LPAR            shift and go to state 37
    SUB             shift and go to state 32
    LITERAL_STR     shift and go to state 38
    ID              shift and go to state 28

    a_expr                         shift and go to state 68
    a_term                         shift and go to state 31
    a_fact                         shift and go to state 33
    varref                         shift and go to state 34

state 51

    (30) a_expr -> a_expr ADD . a_term
    (33) a_term -> . a_term DIV a_fact
    (34) a_term -> . a_term MUL a_fact
    (35) a_term -> . a_fact
    (36) a_fact -> . varref
    (37) a_fact -> . INTEGER
    (38) a_fact -> . FLOAT
    (39) a_fact -> . LPAR a_expr RPAR
    (40) a_fact -> . SUB a_expr
    (41) a_fact -> . LITERAL_STR
    (42) varref -> . ID
    (43) varref -> . ID arr_idx

    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36
    LPAR            shift and go to state 37
    SUB             shift and go to state 32
    LITERAL_STR     shift and go to state 38
    ID              shift and go to state 28

    a_term                         shift and go to state 69
    a_fact                         shift and go to state 33
    varref                         shift and go to state 34

state 52

    (31) a_expr -> a_expr SUB . a_term
    (33) a_term -> . a_term DIV a_fact
    (34) a_term -> . a_term MUL a_fact
    (35) a_term -> . a_fact
    (36) a_fact -> . varref
    (37) a_fact -> . INTEGER
    (38) a_fact -> . FLOAT
    (39) a_fact -> . LPAR a_expr RPAR
    (40) a_fact -> . SUB a_expr
    (41) a_fact -> . LITERAL_STR
    (42) varref -> . ID
    (43) varref -> . ID arr_idx

    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36
    LPAR            shift and go to state 37
    SUB             shift and go to state 32
    LITERAL_STR     shift and go to state 38
    ID              shift and go to state 28

    a_term                         shift and go to state 70
    a_fact                         shift and go to state 33
    varref                         shift and go to state 34

state 53

    (33) a_term -> a_term DIV . a_fact
    (36) a_fact -> . varref
    (37) a_fact -> . INTEGER
    (38) a_fact -> . FLOAT
    (39) a_fact -> . LPAR a_expr RPAR
    (40) a_fact -> . SUB a_expr
    (41) a_fact -> . LITERAL_STR
    (42) varref -> . ID
    (43) varref -> . ID arr_idx

    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36
    LPAR            shift and go to state 37
    SUB             shift and go to state 32
    LITERAL_STR     shift and go to state 38
    ID              shift and go to state 28

    a_fact                         shift and go to state 71
    varref                         shift and go to state 34

state 54

    (34) a_term -> a_term MUL . a_fact
    (36) a_fact -> . varref
    (37) a_fact -> . INTEGER
    (38) a_fact -> . FLOAT
    (39) a_fact -> . LPAR a_expr RPAR
    (40) a_fact -> . SUB a_expr
    (41) a_fact -> . LITERAL_STR
    (42) varref -> . ID
    (43) varref -> . ID arr_idx

    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36
    LPAR            shift and go to state 37
    SUB             shift and go to state 32
    LITERAL_STR     shift and go to state 38
    ID              shift and go to state 28

    a_fact                         shift and go to state 72
    varref                         shift and go to state 34

state 55

    (40) a_fact -> SUB a_expr .
    (30) a_expr -> a_expr . ADD a_term
    (31) a_expr -> a_expr . SUB a_term

  ! shift/reduce conflict for ADD resolved as shift
  ! shift/reduce conflict for SUB resolved as shift
    DIV             reduce using rule 40 (a_fact -> SUB a_expr .)
    MUL             reduce using rule 40 (a_fact -> SUB a_expr .)
    COMMA           reduce using rule 40 (a_fact -> SUB a_expr .)
    SEMICOLON       reduce using rule 40 (a_fact -> SUB a_expr .)
    UNTIL           reduce using rule 40 (a_fact -> SUB a_expr .)
    END             reduce using rule 40 (a_fact -> SUB a_expr .)
    ELSE            reduce using rule 40 (a_fact -> SUB a_expr .)
    RBRACK          reduce using rule 40 (a_fact -> SUB a_expr .)
    RPAR            reduce using rule 40 (a_fact -> SUB a_expr .)
    LT              reduce using rule 40 (a_fact -> SUB a_expr .)
    GT              reduce using rule 40 (a_fact -> SUB a_expr .)
    LEQ             reduce using rule 40 (a_fact -> SUB a_expr .)
    GEQ             reduce using rule 40 (a_fact -> SUB a_expr .)
    ADD             shift and go to state 51
    SUB             shift and go to state 52

  ! ADD             [ reduce using rule 40 (a_fact -> SUB a_expr .) ]
  ! SUB             [ reduce using rule 40 (a_fact -> SUB a_expr .) ]


state 56

    (39) a_fact -> LPAR a_expr . RPAR
    (30) a_expr -> a_expr . ADD a_term
    (31) a_expr -> a_expr . SUB a_term

    RPAR            shift and go to state 73
    ADD             shift and go to state 51
    SUB             shift and go to state 52


state 57

    (25) declaration -> datatype ID arr_size .

    SEMICOLON       reduce using rule 25 (declaration -> datatype ID arr_size .)
    UNTIL           reduce using rule 25 (declaration -> datatype ID arr_size .)
    END             reduce using rule 25 (declaration -> datatype ID arr_size .)
    ELSE            reduce using rule 25 (declaration -> datatype ID arr_size .)


state 58

    (26) arr_size -> LBRACK . a_expr RBRACK
    (30) a_expr -> . a_expr ADD a_term
    (31) a_expr -> . a_expr SUB a_term
    (32) a_expr -> . a_term
    (33) a_term -> . a_term DIV a_fact
    (34) a_term -> . a_term MUL a_fact
    (35) a_term -> . a_fact
    (36) a_fact -> . varref
    (37) a_fact -> . INTEGER
    (38) a_fact -> . FLOAT
    (39) a_fact -> . LPAR a_expr RPAR
    (40) a_fact -> . SUB a_expr
    (41) a_fact -> . LITERAL_STR
    (42) varref -> . ID
    (43) varref -> . ID arr_idx

    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36
    LPAR            shift and go to state 37
    SUB             shift and go to state 32
    LITERAL_STR     shift and go to state 38
    ID              shift and go to state 28

    a_expr                         shift and go to state 74
    a_term                         shift and go to state 31
    a_fact                         shift and go to state 33
    varref                         shift and go to state 34

state 59

    (13) construct_while -> WHILE LPAR l_expr . RPAR DO block

    RPAR            shift and go to state 75


state 60

    (18) l_expr -> a_expr . oprel a_expr
    (30) a_expr -> a_expr . ADD a_term
    (31) a_expr -> a_expr . SUB a_term
    (19) oprel -> . LT
    (20) oprel -> . GT
    (21) oprel -> . LEQ
    (22) oprel -> . GEQ

    ADD             shift and go to state 51
    SUB             shift and go to state 52
    LT              shift and go to state 77
    GT              shift and go to state 78
    LEQ             shift and go to state 79
    GEQ             shift and go to state 80

    oprel                          shift and go to state 76

state 61

    (14) construct_repeat -> REPEAT stmt_list UNTIL . LPAR l_expr RPAR

    LPAR            shift and go to state 81


state 62

    (2) stmt_list -> stmt_list SEMICOLON . stmt
    (4) stmt -> . assignment
    (5) stmt -> . read
    (6) stmt -> . write
    (7) stmt -> . declaration
    (8) stmt -> . construct_while
    (9) stmt -> . construct_repeat
    (10) stmt -> . construct_if
    (11) stmt -> . block
    (23) assignment -> . ID arr_idx ASSIGN a_expr
    (24) assignment -> . ID ASSIGN a_expr
    (45) read -> . READ varlist
    (46) write -> . WRITE expr_list
    (25) declaration -> . datatype ID arr_size
    (13) construct_while -> . WHILE LPAR l_expr RPAR DO block
    (14) construct_repeat -> . REPEAT stmt_list UNTIL LPAR l_expr RPAR
    (15) construct_if -> . IF LPAR l_expr RPAR stmt construct_else
    (12) block -> . BEGIN stmt_list END
    (28) datatype -> . DT_INT
    (29) datatype -> . DT_FLOAT

    ID              shift and go to state 12
    READ            shift and go to state 13
    WRITE           shift and go to state 14
    WHILE           shift and go to state 16
    REPEAT          shift and go to state 17
    IF              shift and go to state 18
    BEGIN           shift and go to state 19
    DT_INT          shift and go to state 20
    DT_FLOAT        shift and go to state 21

    stmt                           shift and go to state 44
    assignment                     shift and go to state 4
    read                           shift and go to state 5
    write                          shift and go to state 6
    declaration                    shift and go to state 7
    construct_while                shift and go to state 8
    construct_repeat               shift and go to state 9
    construct_if                   shift and go to state 10
    block                          shift and go to state 11
    datatype                       shift and go to state 15

state 63

    (15) construct_if -> IF LPAR l_expr . RPAR stmt construct_else

    RPAR            shift and go to state 82


state 64

    (12) block -> BEGIN stmt_list END .

    SEMICOLON       reduce using rule 12 (block -> BEGIN stmt_list END .)
    UNTIL           reduce using rule 12 (block -> BEGIN stmt_list END .)
    END             reduce using rule 12 (block -> BEGIN stmt_list END .)
    ELSE            reduce using rule 12 (block -> BEGIN stmt_list END .)


state 65

    (23) assignment -> ID arr_idx ASSIGN a_expr .
    (30) a_expr -> a_expr . ADD a_term
    (31) a_expr -> a_expr . SUB a_term

    SEMICOLON       reduce using rule 23 (assignment -> ID arr_idx ASSIGN a_expr .)
    UNTIL           reduce using rule 23 (assignment -> ID arr_idx ASSIGN a_expr .)
    END             reduce using rule 23 (assignment -> ID arr_idx ASSIGN a_expr .)
    ELSE            reduce using rule 23 (assignment -> ID arr_idx ASSIGN a_expr .)
    ADD             shift and go to state 51
    SUB             shift and go to state 52


state 66

    (44) arr_idx -> LBRACK a_expr RBRACK .

    ASSIGN          reduce using rule 44 (arr_idx -> LBRACK a_expr RBRACK .)
    COMMA           reduce using rule 44 (arr_idx -> LBRACK a_expr RBRACK .)
    SEMICOLON       reduce using rule 44 (arr_idx -> LBRACK a_expr RBRACK .)
    UNTIL           reduce using rule 44 (arr_idx -> LBRACK a_expr RBRACK .)
    END             reduce using rule 44 (arr_idx -> LBRACK a_expr RBRACK .)
    ELSE            reduce using rule 44 (arr_idx -> LBRACK a_expr RBRACK .)
    DIV             reduce using rule 44 (arr_idx -> LBRACK a_expr RBRACK .)
    MUL             reduce using rule 44 (arr_idx -> LBRACK a_expr RBRACK .)
    ADD             reduce using rule 44 (arr_idx -> LBRACK a_expr RBRACK .)
    SUB             reduce using rule 44 (arr_idx -> LBRACK a_expr RBRACK .)
    RBRACK          reduce using rule 44 (arr_idx -> LBRACK a_expr RBRACK .)
    RPAR            reduce using rule 44 (arr_idx -> LBRACK a_expr RBRACK .)
    LT              reduce using rule 44 (arr_idx -> LBRACK a_expr RBRACK .)
    GT              reduce using rule 44 (arr_idx -> LBRACK a_expr RBRACK .)
    LEQ             reduce using rule 44 (arr_idx -> LBRACK a_expr RBRACK .)
    GEQ             reduce using rule 44 (arr_idx -> LBRACK a_expr RBRACK .)


state 67

    (47) varlist -> varlist COMMA varref .

    COMMA           reduce using rule 47 (varlist -> varlist COMMA varref .)
    SEMICOLON       reduce using rule 47 (varlist -> varlist COMMA varref .)
    UNTIL           reduce using rule 47 (varlist -> varlist COMMA varref .)
    END             reduce using rule 47 (varlist -> varlist COMMA varref .)
    ELSE            reduce using rule 47 (varlist -> varlist COMMA varref .)


state 68

    (49) expr_list -> expr_list COMMA a_expr .
    (30) a_expr -> a_expr . ADD a_term
    (31) a_expr -> a_expr . SUB a_term

    COMMA           reduce using rule 49 (expr_list -> expr_list COMMA a_expr .)
    SEMICOLON       reduce using rule 49 (expr_list -> expr_list COMMA a_expr .)
    UNTIL           reduce using rule 49 (expr_list -> expr_list COMMA a_expr .)
    END             reduce using rule 49 (expr_list -> expr_list COMMA a_expr .)
    ELSE            reduce using rule 49 (expr_list -> expr_list COMMA a_expr .)
    ADD             shift and go to state 51
    SUB             shift and go to state 52


state 69

    (30) a_expr -> a_expr ADD a_term .
    (33) a_term -> a_term . DIV a_fact
    (34) a_term -> a_term . MUL a_fact

  ! shift/reduce conflict for DIV resolved as shift
  ! shift/reduce conflict for MUL resolved as shift
    ADD             reduce using rule 30 (a_expr -> a_expr ADD a_term .)
    SUB             reduce using rule 30 (a_expr -> a_expr ADD a_term .)
    COMMA           reduce using rule 30 (a_expr -> a_expr ADD a_term .)
    SEMICOLON       reduce using rule 30 (a_expr -> a_expr ADD a_term .)
    UNTIL           reduce using rule 30 (a_expr -> a_expr ADD a_term .)
    END             reduce using rule 30 (a_expr -> a_expr ADD a_term .)
    ELSE            reduce using rule 30 (a_expr -> a_expr ADD a_term .)
    RBRACK          reduce using rule 30 (a_expr -> a_expr ADD a_term .)
    RPAR            reduce using rule 30 (a_expr -> a_expr ADD a_term .)
    LT              reduce using rule 30 (a_expr -> a_expr ADD a_term .)
    GT              reduce using rule 30 (a_expr -> a_expr ADD a_term .)
    LEQ             reduce using rule 30 (a_expr -> a_expr ADD a_term .)
    GEQ             reduce using rule 30 (a_expr -> a_expr ADD a_term .)
    DIV             shift and go to state 53
    MUL             shift and go to state 54

  ! DIV             [ reduce using rule 30 (a_expr -> a_expr ADD a_term .) ]
  ! MUL             [ reduce using rule 30 (a_expr -> a_expr ADD a_term .) ]


state 70

    (31) a_expr -> a_expr SUB a_term .
    (33) a_term -> a_term . DIV a_fact
    (34) a_term -> a_term . MUL a_fact

  ! shift/reduce conflict for DIV resolved as shift
  ! shift/reduce conflict for MUL resolved as shift
    ADD             reduce using rule 31 (a_expr -> a_expr SUB a_term .)
    SUB             reduce using rule 31 (a_expr -> a_expr SUB a_term .)
    COMMA           reduce using rule 31 (a_expr -> a_expr SUB a_term .)
    SEMICOLON       reduce using rule 31 (a_expr -> a_expr SUB a_term .)
    UNTIL           reduce using rule 31 (a_expr -> a_expr SUB a_term .)
    END             reduce using rule 31 (a_expr -> a_expr SUB a_term .)
    ELSE            reduce using rule 31 (a_expr -> a_expr SUB a_term .)
    RBRACK          reduce using rule 31 (a_expr -> a_expr SUB a_term .)
    RPAR            reduce using rule 31 (a_expr -> a_expr SUB a_term .)
    LT              reduce using rule 31 (a_expr -> a_expr SUB a_term .)
    GT              reduce using rule 31 (a_expr -> a_expr SUB a_term .)
    LEQ             reduce using rule 31 (a_expr -> a_expr SUB a_term .)
    GEQ             reduce using rule 31 (a_expr -> a_expr SUB a_term .)
    DIV             shift and go to state 53
    MUL             shift and go to state 54

  ! DIV             [ reduce using rule 31 (a_expr -> a_expr SUB a_term .) ]
  ! MUL             [ reduce using rule 31 (a_expr -> a_expr SUB a_term .) ]


state 71

    (33) a_term -> a_term DIV a_fact .

    DIV             reduce using rule 33 (a_term -> a_term DIV a_fact .)
    MUL             reduce using rule 33 (a_term -> a_term DIV a_fact .)
    ADD             reduce using rule 33 (a_term -> a_term DIV a_fact .)
    SUB             reduce using rule 33 (a_term -> a_term DIV a_fact .)
    COMMA           reduce using rule 33 (a_term -> a_term DIV a_fact .)
    SEMICOLON       reduce using rule 33 (a_term -> a_term DIV a_fact .)
    UNTIL           reduce using rule 33 (a_term -> a_term DIV a_fact .)
    END             reduce using rule 33 (a_term -> a_term DIV a_fact .)
    ELSE            reduce using rule 33 (a_term -> a_term DIV a_fact .)
    RBRACK          reduce using rule 33 (a_term -> a_term DIV a_fact .)
    RPAR            reduce using rule 33 (a_term -> a_term DIV a_fact .)
    LT              reduce using rule 33 (a_term -> a_term DIV a_fact .)
    GT              reduce using rule 33 (a_term -> a_term DIV a_fact .)
    LEQ             reduce using rule 33 (a_term -> a_term DIV a_fact .)
    GEQ             reduce using rule 33 (a_term -> a_term DIV a_fact .)


state 72

    (34) a_term -> a_term MUL a_fact .

    DIV             reduce using rule 34 (a_term -> a_term MUL a_fact .)
    MUL             reduce using rule 34 (a_term -> a_term MUL a_fact .)
    ADD             reduce using rule 34 (a_term -> a_term MUL a_fact .)
    SUB             reduce using rule 34 (a_term -> a_term MUL a_fact .)
    COMMA           reduce using rule 34 (a_term -> a_term MUL a_fact .)
    SEMICOLON       reduce using rule 34 (a_term -> a_term MUL a_fact .)
    UNTIL           reduce using rule 34 (a_term -> a_term MUL a_fact .)
    END             reduce using rule 34 (a_term -> a_term MUL a_fact .)
    ELSE            reduce using rule 34 (a_term -> a_term MUL a_fact .)
    RBRACK          reduce using rule 34 (a_term -> a_term MUL a_fact .)
    RPAR            reduce using rule 34 (a_term -> a_term MUL a_fact .)
    LT              reduce using rule 34 (a_term -> a_term MUL a_fact .)
    GT              reduce using rule 34 (a_term -> a_term MUL a_fact .)
    LEQ             reduce using rule 34 (a_term -> a_term MUL a_fact .)
    GEQ             reduce using rule 34 (a_term -> a_term MUL a_fact .)


state 73

    (39) a_fact -> LPAR a_expr RPAR .

    DIV             reduce using rule 39 (a_fact -> LPAR a_expr RPAR .)
    MUL             reduce using rule 39 (a_fact -> LPAR a_expr RPAR .)
    ADD             reduce using rule 39 (a_fact -> LPAR a_expr RPAR .)
    SUB             reduce using rule 39 (a_fact -> LPAR a_expr RPAR .)
    COMMA           reduce using rule 39 (a_fact -> LPAR a_expr RPAR .)
    SEMICOLON       reduce using rule 39 (a_fact -> LPAR a_expr RPAR .)
    UNTIL           reduce using rule 39 (a_fact -> LPAR a_expr RPAR .)
    END             reduce using rule 39 (a_fact -> LPAR a_expr RPAR .)
    ELSE            reduce using rule 39 (a_fact -> LPAR a_expr RPAR .)
    RBRACK          reduce using rule 39 (a_fact -> LPAR a_expr RPAR .)
    RPAR            reduce using rule 39 (a_fact -> LPAR a_expr RPAR .)
    LT              reduce using rule 39 (a_fact -> LPAR a_expr RPAR .)
    GT              reduce using rule 39 (a_fact -> LPAR a_expr RPAR .)
    LEQ             reduce using rule 39 (a_fact -> LPAR a_expr RPAR .)
    GEQ             reduce using rule 39 (a_fact -> LPAR a_expr RPAR .)


state 74

    (26) arr_size -> LBRACK a_expr . RBRACK
    (30) a_expr -> a_expr . ADD a_term
    (31) a_expr -> a_expr . SUB a_term

    RBRACK          shift and go to state 83
    ADD             shift and go to state 51
    SUB             shift and go to state 52


state 75

    (13) construct_while -> WHILE LPAR l_expr RPAR . DO block

    DO              shift and go to state 84


state 76

    (18) l_expr -> a_expr oprel . a_expr
    (30) a_expr -> . a_expr ADD a_term
    (31) a_expr -> . a_expr SUB a_term
    (32) a_expr -> . a_term
    (33) a_term -> . a_term DIV a_fact
    (34) a_term -> . a_term MUL a_fact
    (35) a_term -> . a_fact
    (36) a_fact -> . varref
    (37) a_fact -> . INTEGER
    (38) a_fact -> . FLOAT
    (39) a_fact -> . LPAR a_expr RPAR
    (40) a_fact -> . SUB a_expr
    (41) a_fact -> . LITERAL_STR
    (42) varref -> . ID
    (43) varref -> . ID arr_idx

    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36
    LPAR            shift and go to state 37
    SUB             shift and go to state 32
    LITERAL_STR     shift and go to state 38
    ID              shift and go to state 28

    a_expr                         shift and go to state 85
    a_term                         shift and go to state 31
    a_fact                         shift and go to state 33
    varref                         shift and go to state 34

state 77

    (19) oprel -> LT .

    INTEGER         reduce using rule 19 (oprel -> LT .)
    FLOAT           reduce using rule 19 (oprel -> LT .)
    LPAR            reduce using rule 19 (oprel -> LT .)
    SUB             reduce using rule 19 (oprel -> LT .)
    LITERAL_STR     reduce using rule 19 (oprel -> LT .)
    ID              reduce using rule 19 (oprel -> LT .)


state 78

    (20) oprel -> GT .

    INTEGER         reduce using rule 20 (oprel -> GT .)
    FLOAT           reduce using rule 20 (oprel -> GT .)
    LPAR            reduce using rule 20 (oprel -> GT .)
    SUB             reduce using rule 20 (oprel -> GT .)
    LITERAL_STR     reduce using rule 20 (oprel -> GT .)
    ID              reduce using rule 20 (oprel -> GT .)


state 79

    (21) oprel -> LEQ .

    INTEGER         reduce using rule 21 (oprel -> LEQ .)
    FLOAT           reduce using rule 21 (oprel -> LEQ .)
    LPAR            reduce using rule 21 (oprel -> LEQ .)
    SUB             reduce using rule 21 (oprel -> LEQ .)
    LITERAL_STR     reduce using rule 21 (oprel -> LEQ .)
    ID              reduce using rule 21 (oprel -> LEQ .)


state 80

    (22) oprel -> GEQ .

    INTEGER         reduce using rule 22 (oprel -> GEQ .)
    FLOAT           reduce using rule 22 (oprel -> GEQ .)
    LPAR            reduce using rule 22 (oprel -> GEQ .)
    SUB             reduce using rule 22 (oprel -> GEQ .)
    LITERAL_STR     reduce using rule 22 (oprel -> GEQ .)
    ID              reduce using rule 22 (oprel -> GEQ .)


state 81

    (14) construct_repeat -> REPEAT stmt_list UNTIL LPAR . l_expr RPAR
    (18) l_expr -> . a_expr oprel a_expr
    (30) a_expr -> . a_expr ADD a_term
    (31) a_expr -> . a_expr SUB a_term
    (32) a_expr -> . a_term
    (33) a_term -> . a_term DIV a_fact
    (34) a_term -> . a_term MUL a_fact
    (35) a_term -> . a_fact
    (36) a_fact -> . varref
    (37) a_fact -> . INTEGER
    (38) a_fact -> . FLOAT
    (39) a_fact -> . LPAR a_expr RPAR
    (40) a_fact -> . SUB a_expr
    (41) a_fact -> . LITERAL_STR
    (42) varref -> . ID
    (43) varref -> . ID arr_idx

    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36
    LPAR            shift and go to state 37
    SUB             shift and go to state 32
    LITERAL_STR     shift and go to state 38
    ID              shift and go to state 28

    l_expr                         shift and go to state 86
    a_expr                         shift and go to state 60
    a_term                         shift and go to state 31
    a_fact                         shift and go to state 33
    varref                         shift and go to state 34

state 82

    (15) construct_if -> IF LPAR l_expr RPAR . stmt construct_else
    (4) stmt -> . assignment
    (5) stmt -> . read
    (6) stmt -> . write
    (7) stmt -> . declaration
    (8) stmt -> . construct_while
    (9) stmt -> . construct_repeat
    (10) stmt -> . construct_if
    (11) stmt -> . block
    (23) assignment -> . ID arr_idx ASSIGN a_expr
    (24) assignment -> . ID ASSIGN a_expr
    (45) read -> . READ varlist
    (46) write -> . WRITE expr_list
    (25) declaration -> . datatype ID arr_size
    (13) construct_while -> . WHILE LPAR l_expr RPAR DO block
    (14) construct_repeat -> . REPEAT stmt_list UNTIL LPAR l_expr RPAR
    (15) construct_if -> . IF LPAR l_expr RPAR stmt construct_else
    (12) block -> . BEGIN stmt_list END
    (28) datatype -> . DT_INT
    (29) datatype -> . DT_FLOAT

    ID              shift and go to state 12
    READ            shift and go to state 13
    WRITE           shift and go to state 14
    WHILE           shift and go to state 16
    REPEAT          shift and go to state 17
    IF              shift and go to state 18
    BEGIN           shift and go to state 19
    DT_INT          shift and go to state 20
    DT_FLOAT        shift and go to state 21

    stmt                           shift and go to state 87
    assignment                     shift and go to state 4
    read                           shift and go to state 5
    write                          shift and go to state 6
    declaration                    shift and go to state 7
    construct_while                shift and go to state 8
    construct_repeat               shift and go to state 9
    construct_if                   shift and go to state 10
    block                          shift and go to state 11
    datatype                       shift and go to state 15

state 83

    (26) arr_size -> LBRACK a_expr RBRACK .

    SEMICOLON       reduce using rule 26 (arr_size -> LBRACK a_expr RBRACK .)
    UNTIL           reduce using rule 26 (arr_size -> LBRACK a_expr RBRACK .)
    END             reduce using rule 26 (arr_size -> LBRACK a_expr RBRACK .)
    ELSE            reduce using rule 26 (arr_size -> LBRACK a_expr RBRACK .)


state 84

    (13) construct_while -> WHILE LPAR l_expr RPAR DO . block
    (12) block -> . BEGIN stmt_list END

    BEGIN           shift and go to state 19

    block                          shift and go to state 88

state 85

    (18) l_expr -> a_expr oprel a_expr .
    (30) a_expr -> a_expr . ADD a_term
    (31) a_expr -> a_expr . SUB a_term

    RPAR            reduce using rule 18 (l_expr -> a_expr oprel a_expr .)
    ADD             shift and go to state 51
    SUB             shift and go to state 52


state 86

    (14) construct_repeat -> REPEAT stmt_list UNTIL LPAR l_expr . RPAR

    RPAR            shift and go to state 89


state 87

    (15) construct_if -> IF LPAR l_expr RPAR stmt . construct_else
    (16) construct_else -> .
    (17) construct_else -> . ELSE stmt

  ! shift/reduce conflict for ELSE resolved as shift
    SEMICOLON       reduce using rule 16 (construct_else -> .)
    UNTIL           reduce using rule 16 (construct_else -> .)
    END             reduce using rule 16 (construct_else -> .)
    ELSE            shift and go to state 91

  ! ELSE            [ reduce using rule 16 (construct_else -> .) ]

    construct_else                 shift and go to state 90

state 88

    (13) construct_while -> WHILE LPAR l_expr RPAR DO block .

    SEMICOLON       reduce using rule 13 (construct_while -> WHILE LPAR l_expr RPAR DO block .)
    UNTIL           reduce using rule 13 (construct_while -> WHILE LPAR l_expr RPAR DO block .)
    END             reduce using rule 13 (construct_while -> WHILE LPAR l_expr RPAR DO block .)
    ELSE            reduce using rule 13 (construct_while -> WHILE LPAR l_expr RPAR DO block .)


state 89

    (14) construct_repeat -> REPEAT stmt_list UNTIL LPAR l_expr RPAR .

    SEMICOLON       reduce using rule 14 (construct_repeat -> REPEAT stmt_list UNTIL LPAR l_expr RPAR .)
    UNTIL           reduce using rule 14 (construct_repeat -> REPEAT stmt_list UNTIL LPAR l_expr RPAR .)
    END             reduce using rule 14 (construct_repeat -> REPEAT stmt_list UNTIL LPAR l_expr RPAR .)
    ELSE            reduce using rule 14 (construct_repeat -> REPEAT stmt_list UNTIL LPAR l_expr RPAR .)


state 90

    (15) construct_if -> IF LPAR l_expr RPAR stmt construct_else .

    SEMICOLON       reduce using rule 15 (construct_if -> IF LPAR l_expr RPAR stmt construct_else .)
    UNTIL           reduce using rule 15 (construct_if -> IF LPAR l_expr RPAR stmt construct_else .)
    END             reduce using rule 15 (construct_if -> IF LPAR l_expr RPAR stmt construct_else .)
    ELSE            reduce using rule 15 (construct_if -> IF LPAR l_expr RPAR stmt construct_else .)


state 91

    (17) construct_else -> ELSE . stmt
    (4) stmt -> . assignment
    (5) stmt -> . read
    (6) stmt -> . write
    (7) stmt -> . declaration
    (8) stmt -> . construct_while
    (9) stmt -> . construct_repeat
    (10) stmt -> . construct_if
    (11) stmt -> . block
    (23) assignment -> . ID arr_idx ASSIGN a_expr
    (24) assignment -> . ID ASSIGN a_expr
    (45) read -> . READ varlist
    (46) write -> . WRITE expr_list
    (25) declaration -> . datatype ID arr_size
    (13) construct_while -> . WHILE LPAR l_expr RPAR DO block
    (14) construct_repeat -> . REPEAT stmt_list UNTIL LPAR l_expr RPAR
    (15) construct_if -> . IF LPAR l_expr RPAR stmt construct_else
    (12) block -> . BEGIN stmt_list END
    (28) datatype -> . DT_INT
    (29) datatype -> . DT_FLOAT

    ID              shift and go to state 12
    READ            shift and go to state 13
    WRITE           shift and go to state 14
    WHILE           shift and go to state 16
    REPEAT          shift and go to state 17
    IF              shift and go to state 18
    BEGIN           shift and go to state 19
    DT_INT          shift and go to state 20
    DT_FLOAT        shift and go to state 21

    stmt                           shift and go to state 92
    assignment                     shift and go to state 4
    read                           shift and go to state 5
    write                          shift and go to state 6
    declaration                    shift and go to state 7
    construct_while                shift and go to state 8
    construct_repeat               shift and go to state 9
    construct_if                   shift and go to state 10
    block                          shift and go to state 11
    datatype                       shift and go to state 15

state 92

    (17) construct_else -> ELSE stmt .

    ELSE            reduce using rule 17 (construct_else -> ELSE stmt .)
    SEMICOLON       reduce using rule 17 (construct_else -> ELSE stmt .)
    UNTIL           reduce using rule 17 (construct_else -> ELSE stmt .)
    END             reduce using rule 17 (construct_else -> ELSE stmt .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for DIV in state 31 resolved as shift
WARNING: shift/reduce conflict for MUL in state 31 resolved as shift
WARNING: shift/reduce conflict for ADD in state 55 resolved as shift
WARNING: shift/reduce conflict for SUB in state 55 resolved as shift
WARNING: shift/reduce conflict for DIV in state 69 resolved as shift
WARNING: shift/reduce conflict for MUL in state 69 resolved as shift
WARNING: shift/reduce conflict for DIV in state 70 resolved as shift
WARNING: shift/reduce conflict for MUL in state 70 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 87 resolved as shift
