Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    THEN

Grammar

Rule 0     S' -> program
Rule 1     program -> stmt_list SEMICOLON
Rule 2     stmt_list -> stmt_list SEMICOLON stmt
Rule 3     stmt_list -> stmt
Rule 4     stmt -> assignment
Rule 5     stmt -> read
Rule 6     stmt -> write
Rule 7     stmt -> declaration
Rule 8     stmt -> construct_while
Rule 9     stmt -> construct_repeat
Rule 10    stmt -> construct_if
Rule 11    stmt -> block
Rule 12    block -> BEGIN stmt_list END
Rule 13    construct_while -> WHILE LPAR l_expr RPAR DO block
Rule 14    construct_repeat -> REPEAT stmt_list UNTIL LPAR l_expr RPAR
Rule 15    construct_if -> IF l_expr stmt construct_else
Rule 16    construct_else -> <empty>
Rule 17    construct_else -> ELSE stmt
Rule 18    l_expr -> a_expr oprel a_expr
Rule 19    oprel -> LT
Rule 20    oprel -> GT
Rule 21    oprel -> LEQ
Rule 22    oprel -> GEQ
Rule 23    assignment -> ID arr_idx ASSIGN a_expr
Rule 24    assignment -> ID ASSIGN a_expr
Rule 25    declaration -> datatype ID arr_size
Rule 26    arr_size -> LBRACK a_expr RBRACK
Rule 27    arr_size -> <empty>
Rule 28    datatype -> DT_INT
Rule 29    datatype -> DT_FLOAT
Rule 30    a_expr -> a_expr a_op a_expr
Rule 31    a_expr -> varref
Rule 32    a_expr -> INTEGER
Rule 33    a_expr -> FLOAT
Rule 34    a_expr -> LPAR a_expr RPAR
Rule 35    a_expr -> SUB a_expr
Rule 36    a_expr -> LITERAL_STR
Rule 37    a_op -> ADD
Rule 38    a_op -> SUB
Rule 39    a_op -> MUL
Rule 40    a_op -> DIV
Rule 41    varref -> ID arr_idx
Rule 42    arr_idx -> LBRACK a_expr RBRACK
Rule 43    read -> READ varlist
Rule 44    write -> WRITE expr_list
Rule 45    varlist -> varlist COMMA varref
Rule 46    varlist -> varref
Rule 47    expr_list -> expr_list COMMA a_expr
Rule 48    expr_list -> a_expr

Terminals, with rules where they appear

ADD                  : 37
ASSIGN               : 23 24
BEGIN                : 12
COMMA                : 45 47
DIV                  : 40
DO                   : 13
DT_FLOAT             : 29
DT_INT               : 28
ELSE                 : 17
END                  : 12
FLOAT                : 33
GEQ                  : 22
GT                   : 20
ID                   : 23 24 25 41
IF                   : 15
INTEGER              : 32
LBRACK               : 26 42
LEQ                  : 21
LITERAL_STR          : 36
LPAR                 : 13 14 34
LT                   : 19
MUL                  : 39
RBRACK               : 26 42
READ                 : 43
REPEAT               : 14
RPAR                 : 13 14 34
SEMICOLON            : 1 2
SUB                  : 35 38
THEN                 : 
UNTIL                : 14
WHILE                : 13
WRITE                : 44
error                : 

Nonterminals, with rules where they appear

a_expr               : 18 18 23 24 26 30 30 34 35 42 47 48
a_op                 : 30
arr_idx              : 23 41
arr_size             : 25
assignment           : 4
block                : 11 13
construct_else       : 15
construct_if         : 10
construct_repeat     : 9
construct_while      : 8
datatype             : 25
declaration          : 7
expr_list            : 44 47
l_expr               : 13 14 15
oprel                : 18
program              : 0
read                 : 5
stmt                 : 2 3 15 17
stmt_list            : 1 2 12 14
varlist              : 43 45
varref               : 31 45 46
write                : 6

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . stmt_list SEMICOLON
    (2) stmt_list -> . stmt_list SEMICOLON stmt
    (3) stmt_list -> . stmt
    (4) stmt -> . assignment
    (5) stmt -> . read
    (6) stmt -> . write
    (7) stmt -> . declaration
    (8) stmt -> . construct_while
    (9) stmt -> . construct_repeat
    (10) stmt -> . construct_if
    (11) stmt -> . block
    (23) assignment -> . ID arr_idx ASSIGN a_expr
    (24) assignment -> . ID ASSIGN a_expr
    (43) read -> . READ varlist
    (44) write -> . WRITE expr_list
    (25) declaration -> . datatype ID arr_size
    (13) construct_while -> . WHILE LPAR l_expr RPAR DO block
    (14) construct_repeat -> . REPEAT stmt_list UNTIL LPAR l_expr RPAR
    (15) construct_if -> . IF l_expr stmt construct_else
    (12) block -> . BEGIN stmt_list END
    (28) datatype -> . DT_INT
    (29) datatype -> . DT_FLOAT

    ID              shift and go to state 12
    READ            shift and go to state 13
    WRITE           shift and go to state 14
    WHILE           shift and go to state 16
    REPEAT          shift and go to state 17
    IF              shift and go to state 18
    BEGIN           shift and go to state 19
    DT_INT          shift and go to state 20
    DT_FLOAT        shift and go to state 21

    program                        shift and go to state 1
    stmt_list                      shift and go to state 2
    stmt                           shift and go to state 3
    assignment                     shift and go to state 4
    read                           shift and go to state 5
    write                          shift and go to state 6
    declaration                    shift and go to state 7
    construct_while                shift and go to state 8
    construct_repeat               shift and go to state 9
    construct_if                   shift and go to state 10
    block                          shift and go to state 11
    datatype                       shift and go to state 15

state 1

    (0) S' -> program .



state 2

    (1) program -> stmt_list . SEMICOLON
    (2) stmt_list -> stmt_list . SEMICOLON stmt

    SEMICOLON       shift and go to state 22


state 3

    (3) stmt_list -> stmt .

    SEMICOLON       reduce using rule 3 (stmt_list -> stmt .)
    UNTIL           reduce using rule 3 (stmt_list -> stmt .)
    END             reduce using rule 3 (stmt_list -> stmt .)


state 4

    (4) stmt -> assignment .

    SEMICOLON       reduce using rule 4 (stmt -> assignment .)
    UNTIL           reduce using rule 4 (stmt -> assignment .)
    END             reduce using rule 4 (stmt -> assignment .)
    ELSE            reduce using rule 4 (stmt -> assignment .)


state 5

    (5) stmt -> read .

    SEMICOLON       reduce using rule 5 (stmt -> read .)
    UNTIL           reduce using rule 5 (stmt -> read .)
    END             reduce using rule 5 (stmt -> read .)
    ELSE            reduce using rule 5 (stmt -> read .)


state 6

    (6) stmt -> write .

    SEMICOLON       reduce using rule 6 (stmt -> write .)
    UNTIL           reduce using rule 6 (stmt -> write .)
    END             reduce using rule 6 (stmt -> write .)
    ELSE            reduce using rule 6 (stmt -> write .)


state 7

    (7) stmt -> declaration .

    SEMICOLON       reduce using rule 7 (stmt -> declaration .)
    UNTIL           reduce using rule 7 (stmt -> declaration .)
    END             reduce using rule 7 (stmt -> declaration .)
    ELSE            reduce using rule 7 (stmt -> declaration .)


state 8

    (8) stmt -> construct_while .

    SEMICOLON       reduce using rule 8 (stmt -> construct_while .)
    UNTIL           reduce using rule 8 (stmt -> construct_while .)
    END             reduce using rule 8 (stmt -> construct_while .)
    ELSE            reduce using rule 8 (stmt -> construct_while .)


state 9

    (9) stmt -> construct_repeat .

    SEMICOLON       reduce using rule 9 (stmt -> construct_repeat .)
    UNTIL           reduce using rule 9 (stmt -> construct_repeat .)
    END             reduce using rule 9 (stmt -> construct_repeat .)
    ELSE            reduce using rule 9 (stmt -> construct_repeat .)


state 10

    (10) stmt -> construct_if .

    SEMICOLON       reduce using rule 10 (stmt -> construct_if .)
    UNTIL           reduce using rule 10 (stmt -> construct_if .)
    END             reduce using rule 10 (stmt -> construct_if .)
    ELSE            reduce using rule 10 (stmt -> construct_if .)


state 11

    (11) stmt -> block .

    SEMICOLON       reduce using rule 11 (stmt -> block .)
    UNTIL           reduce using rule 11 (stmt -> block .)
    END             reduce using rule 11 (stmt -> block .)
    ELSE            reduce using rule 11 (stmt -> block .)


state 12

    (23) assignment -> ID . arr_idx ASSIGN a_expr
    (24) assignment -> ID . ASSIGN a_expr
    (42) arr_idx -> . LBRACK a_expr RBRACK

    ASSIGN          shift and go to state 24
    LBRACK          shift and go to state 25

    arr_idx                        shift and go to state 23

state 13

    (43) read -> READ . varlist
    (45) varlist -> . varlist COMMA varref
    (46) varlist -> . varref
    (41) varref -> . ID arr_idx

    ID              shift and go to state 28

    varlist                        shift and go to state 26
    varref                         shift and go to state 27

state 14

    (44) write -> WRITE . expr_list
    (47) expr_list -> . expr_list COMMA a_expr
    (48) expr_list -> . a_expr
    (30) a_expr -> . a_expr a_op a_expr
    (31) a_expr -> . varref
    (32) a_expr -> . INTEGER
    (33) a_expr -> . FLOAT
    (34) a_expr -> . LPAR a_expr RPAR
    (35) a_expr -> . SUB a_expr
    (36) a_expr -> . LITERAL_STR
    (41) varref -> . ID arr_idx

    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 33
    LPAR            shift and go to state 34
    SUB             shift and go to state 35
    LITERAL_STR     shift and go to state 36
    ID              shift and go to state 28

    expr_list                      shift and go to state 29
    a_expr                         shift and go to state 30
    varref                         shift and go to state 31

state 15

    (25) declaration -> datatype . ID arr_size

    ID              shift and go to state 37


state 16

    (13) construct_while -> WHILE . LPAR l_expr RPAR DO block

    LPAR            shift and go to state 38


state 17

    (14) construct_repeat -> REPEAT . stmt_list UNTIL LPAR l_expr RPAR
    (2) stmt_list -> . stmt_list SEMICOLON stmt
    (3) stmt_list -> . stmt
    (4) stmt -> . assignment
    (5) stmt -> . read
    (6) stmt -> . write
    (7) stmt -> . declaration
    (8) stmt -> . construct_while
    (9) stmt -> . construct_repeat
    (10) stmt -> . construct_if
    (11) stmt -> . block
    (23) assignment -> . ID arr_idx ASSIGN a_expr
    (24) assignment -> . ID ASSIGN a_expr
    (43) read -> . READ varlist
    (44) write -> . WRITE expr_list
    (25) declaration -> . datatype ID arr_size
    (13) construct_while -> . WHILE LPAR l_expr RPAR DO block
    (14) construct_repeat -> . REPEAT stmt_list UNTIL LPAR l_expr RPAR
    (15) construct_if -> . IF l_expr stmt construct_else
    (12) block -> . BEGIN stmt_list END
    (28) datatype -> . DT_INT
    (29) datatype -> . DT_FLOAT

    ID              shift and go to state 12
    READ            shift and go to state 13
    WRITE           shift and go to state 14
    WHILE           shift and go to state 16
    REPEAT          shift and go to state 17
    IF              shift and go to state 18
    BEGIN           shift and go to state 19
    DT_INT          shift and go to state 20
    DT_FLOAT        shift and go to state 21

    stmt_list                      shift and go to state 39
    stmt                           shift and go to state 3
    assignment                     shift and go to state 4
    read                           shift and go to state 5
    write                          shift and go to state 6
    declaration                    shift and go to state 7
    construct_while                shift and go to state 8
    construct_repeat               shift and go to state 9
    construct_if                   shift and go to state 10
    block                          shift and go to state 11
    datatype                       shift and go to state 15

state 18

    (15) construct_if -> IF . l_expr stmt construct_else
    (18) l_expr -> . a_expr oprel a_expr
    (30) a_expr -> . a_expr a_op a_expr
    (31) a_expr -> . varref
    (32) a_expr -> . INTEGER
    (33) a_expr -> . FLOAT
    (34) a_expr -> . LPAR a_expr RPAR
    (35) a_expr -> . SUB a_expr
    (36) a_expr -> . LITERAL_STR
    (41) varref -> . ID arr_idx

    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 33
    LPAR            shift and go to state 34
    SUB             shift and go to state 35
    LITERAL_STR     shift and go to state 36
    ID              shift and go to state 28

    l_expr                         shift and go to state 40
    a_expr                         shift and go to state 41
    varref                         shift and go to state 31

state 19

    (12) block -> BEGIN . stmt_list END
    (2) stmt_list -> . stmt_list SEMICOLON stmt
    (3) stmt_list -> . stmt
    (4) stmt -> . assignment
    (5) stmt -> . read
    (6) stmt -> . write
    (7) stmt -> . declaration
    (8) stmt -> . construct_while
    (9) stmt -> . construct_repeat
    (10) stmt -> . construct_if
    (11) stmt -> . block
    (23) assignment -> . ID arr_idx ASSIGN a_expr
    (24) assignment -> . ID ASSIGN a_expr
    (43) read -> . READ varlist
    (44) write -> . WRITE expr_list
    (25) declaration -> . datatype ID arr_size
    (13) construct_while -> . WHILE LPAR l_expr RPAR DO block
    (14) construct_repeat -> . REPEAT stmt_list UNTIL LPAR l_expr RPAR
    (15) construct_if -> . IF l_expr stmt construct_else
    (12) block -> . BEGIN stmt_list END
    (28) datatype -> . DT_INT
    (29) datatype -> . DT_FLOAT

    ID              shift and go to state 12
    READ            shift and go to state 13
    WRITE           shift and go to state 14
    WHILE           shift and go to state 16
    REPEAT          shift and go to state 17
    IF              shift and go to state 18
    BEGIN           shift and go to state 19
    DT_INT          shift and go to state 20
    DT_FLOAT        shift and go to state 21

    stmt_list                      shift and go to state 42
    stmt                           shift and go to state 3
    assignment                     shift and go to state 4
    read                           shift and go to state 5
    write                          shift and go to state 6
    declaration                    shift and go to state 7
    construct_while                shift and go to state 8
    construct_repeat               shift and go to state 9
    construct_if                   shift and go to state 10
    block                          shift and go to state 11
    datatype                       shift and go to state 15

state 20

    (28) datatype -> DT_INT .

    ID              reduce using rule 28 (datatype -> DT_INT .)


state 21

    (29) datatype -> DT_FLOAT .

    ID              reduce using rule 29 (datatype -> DT_FLOAT .)


state 22

    (1) program -> stmt_list SEMICOLON .
    (2) stmt_list -> stmt_list SEMICOLON . stmt
    (4) stmt -> . assignment
    (5) stmt -> . read
    (6) stmt -> . write
    (7) stmt -> . declaration
    (8) stmt -> . construct_while
    (9) stmt -> . construct_repeat
    (10) stmt -> . construct_if
    (11) stmt -> . block
    (23) assignment -> . ID arr_idx ASSIGN a_expr
    (24) assignment -> . ID ASSIGN a_expr
    (43) read -> . READ varlist
    (44) write -> . WRITE expr_list
    (25) declaration -> . datatype ID arr_size
    (13) construct_while -> . WHILE LPAR l_expr RPAR DO block
    (14) construct_repeat -> . REPEAT stmt_list UNTIL LPAR l_expr RPAR
    (15) construct_if -> . IF l_expr stmt construct_else
    (12) block -> . BEGIN stmt_list END
    (28) datatype -> . DT_INT
    (29) datatype -> . DT_FLOAT

    $end            reduce using rule 1 (program -> stmt_list SEMICOLON .)
    ID              shift and go to state 12
    READ            shift and go to state 13
    WRITE           shift and go to state 14
    WHILE           shift and go to state 16
    REPEAT          shift and go to state 17
    IF              shift and go to state 18
    BEGIN           shift and go to state 19
    DT_INT          shift and go to state 20
    DT_FLOAT        shift and go to state 21

    stmt                           shift and go to state 43
    assignment                     shift and go to state 4
    read                           shift and go to state 5
    write                          shift and go to state 6
    declaration                    shift and go to state 7
    construct_while                shift and go to state 8
    construct_repeat               shift and go to state 9
    construct_if                   shift and go to state 10
    block                          shift and go to state 11
    datatype                       shift and go to state 15

state 23

    (23) assignment -> ID arr_idx . ASSIGN a_expr

    ASSIGN          shift and go to state 44


state 24

    (24) assignment -> ID ASSIGN . a_expr
    (30) a_expr -> . a_expr a_op a_expr
    (31) a_expr -> . varref
    (32) a_expr -> . INTEGER
    (33) a_expr -> . FLOAT
    (34) a_expr -> . LPAR a_expr RPAR
    (35) a_expr -> . SUB a_expr
    (36) a_expr -> . LITERAL_STR
    (41) varref -> . ID arr_idx

    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 33
    LPAR            shift and go to state 34
    SUB             shift and go to state 35
    LITERAL_STR     shift and go to state 36
    ID              shift and go to state 28

    a_expr                         shift and go to state 45
    varref                         shift and go to state 31

state 25

    (42) arr_idx -> LBRACK . a_expr RBRACK
    (30) a_expr -> . a_expr a_op a_expr
    (31) a_expr -> . varref
    (32) a_expr -> . INTEGER
    (33) a_expr -> . FLOAT
    (34) a_expr -> . LPAR a_expr RPAR
    (35) a_expr -> . SUB a_expr
    (36) a_expr -> . LITERAL_STR
    (41) varref -> . ID arr_idx

    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 33
    LPAR            shift and go to state 34
    SUB             shift and go to state 35
    LITERAL_STR     shift and go to state 36
    ID              shift and go to state 28

    a_expr                         shift and go to state 46
    varref                         shift and go to state 31

state 26

    (43) read -> READ varlist .
    (45) varlist -> varlist . COMMA varref

    SEMICOLON       reduce using rule 43 (read -> READ varlist .)
    UNTIL           reduce using rule 43 (read -> READ varlist .)
    END             reduce using rule 43 (read -> READ varlist .)
    ELSE            reduce using rule 43 (read -> READ varlist .)
    COMMA           shift and go to state 47


state 27

    (46) varlist -> varref .

    COMMA           reduce using rule 46 (varlist -> varref .)
    SEMICOLON       reduce using rule 46 (varlist -> varref .)
    UNTIL           reduce using rule 46 (varlist -> varref .)
    END             reduce using rule 46 (varlist -> varref .)
    ELSE            reduce using rule 46 (varlist -> varref .)


state 28

    (41) varref -> ID . arr_idx
    (42) arr_idx -> . LBRACK a_expr RBRACK

    LBRACK          shift and go to state 25

    arr_idx                        shift and go to state 48

state 29

    (44) write -> WRITE expr_list .
    (47) expr_list -> expr_list . COMMA a_expr

    SEMICOLON       reduce using rule 44 (write -> WRITE expr_list .)
    UNTIL           reduce using rule 44 (write -> WRITE expr_list .)
    END             reduce using rule 44 (write -> WRITE expr_list .)
    ELSE            reduce using rule 44 (write -> WRITE expr_list .)
    COMMA           shift and go to state 49


state 30

    (48) expr_list -> a_expr .
    (30) a_expr -> a_expr . a_op a_expr
    (37) a_op -> . ADD
    (38) a_op -> . SUB
    (39) a_op -> . MUL
    (40) a_op -> . DIV

    COMMA           reduce using rule 48 (expr_list -> a_expr .)
    SEMICOLON       reduce using rule 48 (expr_list -> a_expr .)
    UNTIL           reduce using rule 48 (expr_list -> a_expr .)
    END             reduce using rule 48 (expr_list -> a_expr .)
    ELSE            reduce using rule 48 (expr_list -> a_expr .)
    ADD             shift and go to state 51
    SUB             shift and go to state 52
    MUL             shift and go to state 53
    DIV             shift and go to state 54

    a_op                           shift and go to state 50

state 31

    (31) a_expr -> varref .

    ADD             reduce using rule 31 (a_expr -> varref .)
    SUB             reduce using rule 31 (a_expr -> varref .)
    MUL             reduce using rule 31 (a_expr -> varref .)
    DIV             reduce using rule 31 (a_expr -> varref .)
    COMMA           reduce using rule 31 (a_expr -> varref .)
    SEMICOLON       reduce using rule 31 (a_expr -> varref .)
    UNTIL           reduce using rule 31 (a_expr -> varref .)
    END             reduce using rule 31 (a_expr -> varref .)
    ELSE            reduce using rule 31 (a_expr -> varref .)
    LT              reduce using rule 31 (a_expr -> varref .)
    GT              reduce using rule 31 (a_expr -> varref .)
    LEQ             reduce using rule 31 (a_expr -> varref .)
    GEQ             reduce using rule 31 (a_expr -> varref .)
    RBRACK          reduce using rule 31 (a_expr -> varref .)
    RPAR            reduce using rule 31 (a_expr -> varref .)
    ID              reduce using rule 31 (a_expr -> varref .)
    READ            reduce using rule 31 (a_expr -> varref .)
    WRITE           reduce using rule 31 (a_expr -> varref .)
    WHILE           reduce using rule 31 (a_expr -> varref .)
    REPEAT          reduce using rule 31 (a_expr -> varref .)
    IF              reduce using rule 31 (a_expr -> varref .)
    BEGIN           reduce using rule 31 (a_expr -> varref .)
    DT_INT          reduce using rule 31 (a_expr -> varref .)
    DT_FLOAT        reduce using rule 31 (a_expr -> varref .)


state 32

    (32) a_expr -> INTEGER .

    ADD             reduce using rule 32 (a_expr -> INTEGER .)
    SUB             reduce using rule 32 (a_expr -> INTEGER .)
    MUL             reduce using rule 32 (a_expr -> INTEGER .)
    DIV             reduce using rule 32 (a_expr -> INTEGER .)
    COMMA           reduce using rule 32 (a_expr -> INTEGER .)
    SEMICOLON       reduce using rule 32 (a_expr -> INTEGER .)
    UNTIL           reduce using rule 32 (a_expr -> INTEGER .)
    END             reduce using rule 32 (a_expr -> INTEGER .)
    ELSE            reduce using rule 32 (a_expr -> INTEGER .)
    LT              reduce using rule 32 (a_expr -> INTEGER .)
    GT              reduce using rule 32 (a_expr -> INTEGER .)
    LEQ             reduce using rule 32 (a_expr -> INTEGER .)
    GEQ             reduce using rule 32 (a_expr -> INTEGER .)
    RBRACK          reduce using rule 32 (a_expr -> INTEGER .)
    RPAR            reduce using rule 32 (a_expr -> INTEGER .)
    ID              reduce using rule 32 (a_expr -> INTEGER .)
    READ            reduce using rule 32 (a_expr -> INTEGER .)
    WRITE           reduce using rule 32 (a_expr -> INTEGER .)
    WHILE           reduce using rule 32 (a_expr -> INTEGER .)
    REPEAT          reduce using rule 32 (a_expr -> INTEGER .)
    IF              reduce using rule 32 (a_expr -> INTEGER .)
    BEGIN           reduce using rule 32 (a_expr -> INTEGER .)
    DT_INT          reduce using rule 32 (a_expr -> INTEGER .)
    DT_FLOAT        reduce using rule 32 (a_expr -> INTEGER .)


state 33

    (33) a_expr -> FLOAT .

    ADD             reduce using rule 33 (a_expr -> FLOAT .)
    SUB             reduce using rule 33 (a_expr -> FLOAT .)
    MUL             reduce using rule 33 (a_expr -> FLOAT .)
    DIV             reduce using rule 33 (a_expr -> FLOAT .)
    COMMA           reduce using rule 33 (a_expr -> FLOAT .)
    SEMICOLON       reduce using rule 33 (a_expr -> FLOAT .)
    UNTIL           reduce using rule 33 (a_expr -> FLOAT .)
    END             reduce using rule 33 (a_expr -> FLOAT .)
    ELSE            reduce using rule 33 (a_expr -> FLOAT .)
    LT              reduce using rule 33 (a_expr -> FLOAT .)
    GT              reduce using rule 33 (a_expr -> FLOAT .)
    LEQ             reduce using rule 33 (a_expr -> FLOAT .)
    GEQ             reduce using rule 33 (a_expr -> FLOAT .)
    RBRACK          reduce using rule 33 (a_expr -> FLOAT .)
    RPAR            reduce using rule 33 (a_expr -> FLOAT .)
    ID              reduce using rule 33 (a_expr -> FLOAT .)
    READ            reduce using rule 33 (a_expr -> FLOAT .)
    WRITE           reduce using rule 33 (a_expr -> FLOAT .)
    WHILE           reduce using rule 33 (a_expr -> FLOAT .)
    REPEAT          reduce using rule 33 (a_expr -> FLOAT .)
    IF              reduce using rule 33 (a_expr -> FLOAT .)
    BEGIN           reduce using rule 33 (a_expr -> FLOAT .)
    DT_INT          reduce using rule 33 (a_expr -> FLOAT .)
    DT_FLOAT        reduce using rule 33 (a_expr -> FLOAT .)


state 34

    (34) a_expr -> LPAR . a_expr RPAR
    (30) a_expr -> . a_expr a_op a_expr
    (31) a_expr -> . varref
    (32) a_expr -> . INTEGER
    (33) a_expr -> . FLOAT
    (34) a_expr -> . LPAR a_expr RPAR
    (35) a_expr -> . SUB a_expr
    (36) a_expr -> . LITERAL_STR
    (41) varref -> . ID arr_idx

    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 33
    LPAR            shift and go to state 34
    SUB             shift and go to state 35
    LITERAL_STR     shift and go to state 36
    ID              shift and go to state 28

    a_expr                         shift and go to state 55
    varref                         shift and go to state 31

state 35

    (35) a_expr -> SUB . a_expr
    (30) a_expr -> . a_expr a_op a_expr
    (31) a_expr -> . varref
    (32) a_expr -> . INTEGER
    (33) a_expr -> . FLOAT
    (34) a_expr -> . LPAR a_expr RPAR
    (35) a_expr -> . SUB a_expr
    (36) a_expr -> . LITERAL_STR
    (41) varref -> . ID arr_idx

    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 33
    LPAR            shift and go to state 34
    SUB             shift and go to state 35
    LITERAL_STR     shift and go to state 36
    ID              shift and go to state 28

    a_expr                         shift and go to state 56
    varref                         shift and go to state 31

state 36

    (36) a_expr -> LITERAL_STR .

    ADD             reduce using rule 36 (a_expr -> LITERAL_STR .)
    SUB             reduce using rule 36 (a_expr -> LITERAL_STR .)
    MUL             reduce using rule 36 (a_expr -> LITERAL_STR .)
    DIV             reduce using rule 36 (a_expr -> LITERAL_STR .)
    COMMA           reduce using rule 36 (a_expr -> LITERAL_STR .)
    SEMICOLON       reduce using rule 36 (a_expr -> LITERAL_STR .)
    UNTIL           reduce using rule 36 (a_expr -> LITERAL_STR .)
    END             reduce using rule 36 (a_expr -> LITERAL_STR .)
    ELSE            reduce using rule 36 (a_expr -> LITERAL_STR .)
    LT              reduce using rule 36 (a_expr -> LITERAL_STR .)
    GT              reduce using rule 36 (a_expr -> LITERAL_STR .)
    LEQ             reduce using rule 36 (a_expr -> LITERAL_STR .)
    GEQ             reduce using rule 36 (a_expr -> LITERAL_STR .)
    RBRACK          reduce using rule 36 (a_expr -> LITERAL_STR .)
    RPAR            reduce using rule 36 (a_expr -> LITERAL_STR .)
    ID              reduce using rule 36 (a_expr -> LITERAL_STR .)
    READ            reduce using rule 36 (a_expr -> LITERAL_STR .)
    WRITE           reduce using rule 36 (a_expr -> LITERAL_STR .)
    WHILE           reduce using rule 36 (a_expr -> LITERAL_STR .)
    REPEAT          reduce using rule 36 (a_expr -> LITERAL_STR .)
    IF              reduce using rule 36 (a_expr -> LITERAL_STR .)
    BEGIN           reduce using rule 36 (a_expr -> LITERAL_STR .)
    DT_INT          reduce using rule 36 (a_expr -> LITERAL_STR .)
    DT_FLOAT        reduce using rule 36 (a_expr -> LITERAL_STR .)


state 37

    (25) declaration -> datatype ID . arr_size
    (26) arr_size -> . LBRACK a_expr RBRACK
    (27) arr_size -> .

    LBRACK          shift and go to state 58
    SEMICOLON       reduce using rule 27 (arr_size -> .)
    UNTIL           reduce using rule 27 (arr_size -> .)
    END             reduce using rule 27 (arr_size -> .)
    ELSE            reduce using rule 27 (arr_size -> .)

    arr_size                       shift and go to state 57

state 38

    (13) construct_while -> WHILE LPAR . l_expr RPAR DO block
    (18) l_expr -> . a_expr oprel a_expr
    (30) a_expr -> . a_expr a_op a_expr
    (31) a_expr -> . varref
    (32) a_expr -> . INTEGER
    (33) a_expr -> . FLOAT
    (34) a_expr -> . LPAR a_expr RPAR
    (35) a_expr -> . SUB a_expr
    (36) a_expr -> . LITERAL_STR
    (41) varref -> . ID arr_idx

    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 33
    LPAR            shift and go to state 34
    SUB             shift and go to state 35
    LITERAL_STR     shift and go to state 36
    ID              shift and go to state 28

    l_expr                         shift and go to state 59
    a_expr                         shift and go to state 41
    varref                         shift and go to state 31

state 39

    (14) construct_repeat -> REPEAT stmt_list . UNTIL LPAR l_expr RPAR
    (2) stmt_list -> stmt_list . SEMICOLON stmt

    UNTIL           shift and go to state 60
    SEMICOLON       shift and go to state 61


state 40

    (15) construct_if -> IF l_expr . stmt construct_else
    (4) stmt -> . assignment
    (5) stmt -> . read
    (6) stmt -> . write
    (7) stmt -> . declaration
    (8) stmt -> . construct_while
    (9) stmt -> . construct_repeat
    (10) stmt -> . construct_if
    (11) stmt -> . block
    (23) assignment -> . ID arr_idx ASSIGN a_expr
    (24) assignment -> . ID ASSIGN a_expr
    (43) read -> . READ varlist
    (44) write -> . WRITE expr_list
    (25) declaration -> . datatype ID arr_size
    (13) construct_while -> . WHILE LPAR l_expr RPAR DO block
    (14) construct_repeat -> . REPEAT stmt_list UNTIL LPAR l_expr RPAR
    (15) construct_if -> . IF l_expr stmt construct_else
    (12) block -> . BEGIN stmt_list END
    (28) datatype -> . DT_INT
    (29) datatype -> . DT_FLOAT

    ID              shift and go to state 12
    READ            shift and go to state 13
    WRITE           shift and go to state 14
    WHILE           shift and go to state 16
    REPEAT          shift and go to state 17
    IF              shift and go to state 18
    BEGIN           shift and go to state 19
    DT_INT          shift and go to state 20
    DT_FLOAT        shift and go to state 21

    stmt                           shift and go to state 62
    assignment                     shift and go to state 4
    read                           shift and go to state 5
    write                          shift and go to state 6
    declaration                    shift and go to state 7
    construct_while                shift and go to state 8
    construct_repeat               shift and go to state 9
    construct_if                   shift and go to state 10
    block                          shift and go to state 11
    datatype                       shift and go to state 15

state 41

    (18) l_expr -> a_expr . oprel a_expr
    (30) a_expr -> a_expr . a_op a_expr
    (19) oprel -> . LT
    (20) oprel -> . GT
    (21) oprel -> . LEQ
    (22) oprel -> . GEQ
    (37) a_op -> . ADD
    (38) a_op -> . SUB
    (39) a_op -> . MUL
    (40) a_op -> . DIV

    LT              shift and go to state 64
    GT              shift and go to state 65
    LEQ             shift and go to state 66
    GEQ             shift and go to state 67
    ADD             shift and go to state 51
    SUB             shift and go to state 52
    MUL             shift and go to state 53
    DIV             shift and go to state 54

    oprel                          shift and go to state 63
    a_op                           shift and go to state 50

state 42

    (12) block -> BEGIN stmt_list . END
    (2) stmt_list -> stmt_list . SEMICOLON stmt

    END             shift and go to state 68
    SEMICOLON       shift and go to state 61


state 43

    (2) stmt_list -> stmt_list SEMICOLON stmt .

    SEMICOLON       reduce using rule 2 (stmt_list -> stmt_list SEMICOLON stmt .)
    UNTIL           reduce using rule 2 (stmt_list -> stmt_list SEMICOLON stmt .)
    END             reduce using rule 2 (stmt_list -> stmt_list SEMICOLON stmt .)


state 44

    (23) assignment -> ID arr_idx ASSIGN . a_expr
    (30) a_expr -> . a_expr a_op a_expr
    (31) a_expr -> . varref
    (32) a_expr -> . INTEGER
    (33) a_expr -> . FLOAT
    (34) a_expr -> . LPAR a_expr RPAR
    (35) a_expr -> . SUB a_expr
    (36) a_expr -> . LITERAL_STR
    (41) varref -> . ID arr_idx

    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 33
    LPAR            shift and go to state 34
    SUB             shift and go to state 35
    LITERAL_STR     shift and go to state 36
    ID              shift and go to state 28

    a_expr                         shift and go to state 69
    varref                         shift and go to state 31

state 45

    (24) assignment -> ID ASSIGN a_expr .
    (30) a_expr -> a_expr . a_op a_expr
    (37) a_op -> . ADD
    (38) a_op -> . SUB
    (39) a_op -> . MUL
    (40) a_op -> . DIV

    SEMICOLON       reduce using rule 24 (assignment -> ID ASSIGN a_expr .)
    UNTIL           reduce using rule 24 (assignment -> ID ASSIGN a_expr .)
    END             reduce using rule 24 (assignment -> ID ASSIGN a_expr .)
    ELSE            reduce using rule 24 (assignment -> ID ASSIGN a_expr .)
    ADD             shift and go to state 51
    SUB             shift and go to state 52
    MUL             shift and go to state 53
    DIV             shift and go to state 54

    a_op                           shift and go to state 50

state 46

    (42) arr_idx -> LBRACK a_expr . RBRACK
    (30) a_expr -> a_expr . a_op a_expr
    (37) a_op -> . ADD
    (38) a_op -> . SUB
    (39) a_op -> . MUL
    (40) a_op -> . DIV

    RBRACK          shift and go to state 70
    ADD             shift and go to state 51
    SUB             shift and go to state 52
    MUL             shift and go to state 53
    DIV             shift and go to state 54

    a_op                           shift and go to state 50

state 47

    (45) varlist -> varlist COMMA . varref
    (41) varref -> . ID arr_idx

    ID              shift and go to state 28

    varref                         shift and go to state 71

state 48

    (41) varref -> ID arr_idx .

    COMMA           reduce using rule 41 (varref -> ID arr_idx .)
    SEMICOLON       reduce using rule 41 (varref -> ID arr_idx .)
    UNTIL           reduce using rule 41 (varref -> ID arr_idx .)
    END             reduce using rule 41 (varref -> ID arr_idx .)
    ELSE            reduce using rule 41 (varref -> ID arr_idx .)
    ADD             reduce using rule 41 (varref -> ID arr_idx .)
    SUB             reduce using rule 41 (varref -> ID arr_idx .)
    MUL             reduce using rule 41 (varref -> ID arr_idx .)
    DIV             reduce using rule 41 (varref -> ID arr_idx .)
    LT              reduce using rule 41 (varref -> ID arr_idx .)
    GT              reduce using rule 41 (varref -> ID arr_idx .)
    LEQ             reduce using rule 41 (varref -> ID arr_idx .)
    GEQ             reduce using rule 41 (varref -> ID arr_idx .)
    RBRACK          reduce using rule 41 (varref -> ID arr_idx .)
    RPAR            reduce using rule 41 (varref -> ID arr_idx .)
    ID              reduce using rule 41 (varref -> ID arr_idx .)
    READ            reduce using rule 41 (varref -> ID arr_idx .)
    WRITE           reduce using rule 41 (varref -> ID arr_idx .)
    WHILE           reduce using rule 41 (varref -> ID arr_idx .)
    REPEAT          reduce using rule 41 (varref -> ID arr_idx .)
    IF              reduce using rule 41 (varref -> ID arr_idx .)
    BEGIN           reduce using rule 41 (varref -> ID arr_idx .)
    DT_INT          reduce using rule 41 (varref -> ID arr_idx .)
    DT_FLOAT        reduce using rule 41 (varref -> ID arr_idx .)


state 49

    (47) expr_list -> expr_list COMMA . a_expr
    (30) a_expr -> . a_expr a_op a_expr
    (31) a_expr -> . varref
    (32) a_expr -> . INTEGER
    (33) a_expr -> . FLOAT
    (34) a_expr -> . LPAR a_expr RPAR
    (35) a_expr -> . SUB a_expr
    (36) a_expr -> . LITERAL_STR
    (41) varref -> . ID arr_idx

    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 33
    LPAR            shift and go to state 34
    SUB             shift and go to state 35
    LITERAL_STR     shift and go to state 36
    ID              shift and go to state 28

    a_expr                         shift and go to state 72
    varref                         shift and go to state 31

state 50

    (30) a_expr -> a_expr a_op . a_expr
    (30) a_expr -> . a_expr a_op a_expr
    (31) a_expr -> . varref
    (32) a_expr -> . INTEGER
    (33) a_expr -> . FLOAT
    (34) a_expr -> . LPAR a_expr RPAR
    (35) a_expr -> . SUB a_expr
    (36) a_expr -> . LITERAL_STR
    (41) varref -> . ID arr_idx

    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 33
    LPAR            shift and go to state 34
    SUB             shift and go to state 35
    LITERAL_STR     shift and go to state 36
    ID              shift and go to state 28

    a_expr                         shift and go to state 73
    varref                         shift and go to state 31

state 51

    (37) a_op -> ADD .

    INTEGER         reduce using rule 37 (a_op -> ADD .)
    FLOAT           reduce using rule 37 (a_op -> ADD .)
    LPAR            reduce using rule 37 (a_op -> ADD .)
    SUB             reduce using rule 37 (a_op -> ADD .)
    LITERAL_STR     reduce using rule 37 (a_op -> ADD .)
    ID              reduce using rule 37 (a_op -> ADD .)


state 52

    (38) a_op -> SUB .

    INTEGER         reduce using rule 38 (a_op -> SUB .)
    FLOAT           reduce using rule 38 (a_op -> SUB .)
    LPAR            reduce using rule 38 (a_op -> SUB .)
    SUB             reduce using rule 38 (a_op -> SUB .)
    LITERAL_STR     reduce using rule 38 (a_op -> SUB .)
    ID              reduce using rule 38 (a_op -> SUB .)


state 53

    (39) a_op -> MUL .

    INTEGER         reduce using rule 39 (a_op -> MUL .)
    FLOAT           reduce using rule 39 (a_op -> MUL .)
    LPAR            reduce using rule 39 (a_op -> MUL .)
    SUB             reduce using rule 39 (a_op -> MUL .)
    LITERAL_STR     reduce using rule 39 (a_op -> MUL .)
    ID              reduce using rule 39 (a_op -> MUL .)


state 54

    (40) a_op -> DIV .

    INTEGER         reduce using rule 40 (a_op -> DIV .)
    FLOAT           reduce using rule 40 (a_op -> DIV .)
    LPAR            reduce using rule 40 (a_op -> DIV .)
    SUB             reduce using rule 40 (a_op -> DIV .)
    LITERAL_STR     reduce using rule 40 (a_op -> DIV .)
    ID              reduce using rule 40 (a_op -> DIV .)


state 55

    (34) a_expr -> LPAR a_expr . RPAR
    (30) a_expr -> a_expr . a_op a_expr
    (37) a_op -> . ADD
    (38) a_op -> . SUB
    (39) a_op -> . MUL
    (40) a_op -> . DIV

    RPAR            shift and go to state 74
    ADD             shift and go to state 51
    SUB             shift and go to state 52
    MUL             shift and go to state 53
    DIV             shift and go to state 54

    a_op                           shift and go to state 50

state 56

    (35) a_expr -> SUB a_expr .
    (30) a_expr -> a_expr . a_op a_expr
    (37) a_op -> . ADD
    (38) a_op -> . SUB
    (39) a_op -> . MUL
    (40) a_op -> . DIV

  ! shift/reduce conflict for ADD resolved as shift
  ! shift/reduce conflict for SUB resolved as shift
  ! shift/reduce conflict for MUL resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
    COMMA           reduce using rule 35 (a_expr -> SUB a_expr .)
    SEMICOLON       reduce using rule 35 (a_expr -> SUB a_expr .)
    UNTIL           reduce using rule 35 (a_expr -> SUB a_expr .)
    END             reduce using rule 35 (a_expr -> SUB a_expr .)
    ELSE            reduce using rule 35 (a_expr -> SUB a_expr .)
    LT              reduce using rule 35 (a_expr -> SUB a_expr .)
    GT              reduce using rule 35 (a_expr -> SUB a_expr .)
    LEQ             reduce using rule 35 (a_expr -> SUB a_expr .)
    GEQ             reduce using rule 35 (a_expr -> SUB a_expr .)
    RBRACK          reduce using rule 35 (a_expr -> SUB a_expr .)
    RPAR            reduce using rule 35 (a_expr -> SUB a_expr .)
    ID              reduce using rule 35 (a_expr -> SUB a_expr .)
    READ            reduce using rule 35 (a_expr -> SUB a_expr .)
    WRITE           reduce using rule 35 (a_expr -> SUB a_expr .)
    WHILE           reduce using rule 35 (a_expr -> SUB a_expr .)
    REPEAT          reduce using rule 35 (a_expr -> SUB a_expr .)
    IF              reduce using rule 35 (a_expr -> SUB a_expr .)
    BEGIN           reduce using rule 35 (a_expr -> SUB a_expr .)
    DT_INT          reduce using rule 35 (a_expr -> SUB a_expr .)
    DT_FLOAT        reduce using rule 35 (a_expr -> SUB a_expr .)
    ADD             shift and go to state 51
    SUB             shift and go to state 52
    MUL             shift and go to state 53
    DIV             shift and go to state 54

  ! ADD             [ reduce using rule 35 (a_expr -> SUB a_expr .) ]
  ! SUB             [ reduce using rule 35 (a_expr -> SUB a_expr .) ]
  ! MUL             [ reduce using rule 35 (a_expr -> SUB a_expr .) ]
  ! DIV             [ reduce using rule 35 (a_expr -> SUB a_expr .) ]

    a_op                           shift and go to state 50

state 57

    (25) declaration -> datatype ID arr_size .

    SEMICOLON       reduce using rule 25 (declaration -> datatype ID arr_size .)
    UNTIL           reduce using rule 25 (declaration -> datatype ID arr_size .)
    END             reduce using rule 25 (declaration -> datatype ID arr_size .)
    ELSE            reduce using rule 25 (declaration -> datatype ID arr_size .)


state 58

    (26) arr_size -> LBRACK . a_expr RBRACK
    (30) a_expr -> . a_expr a_op a_expr
    (31) a_expr -> . varref
    (32) a_expr -> . INTEGER
    (33) a_expr -> . FLOAT
    (34) a_expr -> . LPAR a_expr RPAR
    (35) a_expr -> . SUB a_expr
    (36) a_expr -> . LITERAL_STR
    (41) varref -> . ID arr_idx

    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 33
    LPAR            shift and go to state 34
    SUB             shift and go to state 35
    LITERAL_STR     shift and go to state 36
    ID              shift and go to state 28

    a_expr                         shift and go to state 75
    varref                         shift and go to state 31

state 59

    (13) construct_while -> WHILE LPAR l_expr . RPAR DO block

    RPAR            shift and go to state 76


state 60

    (14) construct_repeat -> REPEAT stmt_list UNTIL . LPAR l_expr RPAR

    LPAR            shift and go to state 77


state 61

    (2) stmt_list -> stmt_list SEMICOLON . stmt
    (4) stmt -> . assignment
    (5) stmt -> . read
    (6) stmt -> . write
    (7) stmt -> . declaration
    (8) stmt -> . construct_while
    (9) stmt -> . construct_repeat
    (10) stmt -> . construct_if
    (11) stmt -> . block
    (23) assignment -> . ID arr_idx ASSIGN a_expr
    (24) assignment -> . ID ASSIGN a_expr
    (43) read -> . READ varlist
    (44) write -> . WRITE expr_list
    (25) declaration -> . datatype ID arr_size
    (13) construct_while -> . WHILE LPAR l_expr RPAR DO block
    (14) construct_repeat -> . REPEAT stmt_list UNTIL LPAR l_expr RPAR
    (15) construct_if -> . IF l_expr stmt construct_else
    (12) block -> . BEGIN stmt_list END
    (28) datatype -> . DT_INT
    (29) datatype -> . DT_FLOAT

    ID              shift and go to state 12
    READ            shift and go to state 13
    WRITE           shift and go to state 14
    WHILE           shift and go to state 16
    REPEAT          shift and go to state 17
    IF              shift and go to state 18
    BEGIN           shift and go to state 19
    DT_INT          shift and go to state 20
    DT_FLOAT        shift and go to state 21

    stmt                           shift and go to state 43
    assignment                     shift and go to state 4
    read                           shift and go to state 5
    write                          shift and go to state 6
    declaration                    shift and go to state 7
    construct_while                shift and go to state 8
    construct_repeat               shift and go to state 9
    construct_if                   shift and go to state 10
    block                          shift and go to state 11
    datatype                       shift and go to state 15

state 62

    (15) construct_if -> IF l_expr stmt . construct_else
    (16) construct_else -> .
    (17) construct_else -> . ELSE stmt

  ! shift/reduce conflict for ELSE resolved as shift
    SEMICOLON       reduce using rule 16 (construct_else -> .)
    UNTIL           reduce using rule 16 (construct_else -> .)
    END             reduce using rule 16 (construct_else -> .)
    ELSE            shift and go to state 79

  ! ELSE            [ reduce using rule 16 (construct_else -> .) ]

    construct_else                 shift and go to state 78

state 63

    (18) l_expr -> a_expr oprel . a_expr
    (30) a_expr -> . a_expr a_op a_expr
    (31) a_expr -> . varref
    (32) a_expr -> . INTEGER
    (33) a_expr -> . FLOAT
    (34) a_expr -> . LPAR a_expr RPAR
    (35) a_expr -> . SUB a_expr
    (36) a_expr -> . LITERAL_STR
    (41) varref -> . ID arr_idx

    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 33
    LPAR            shift and go to state 34
    SUB             shift and go to state 35
    LITERAL_STR     shift and go to state 36
    ID              shift and go to state 28

    a_expr                         shift and go to state 80
    varref                         shift and go to state 31

state 64

    (19) oprel -> LT .

    INTEGER         reduce using rule 19 (oprel -> LT .)
    FLOAT           reduce using rule 19 (oprel -> LT .)
    LPAR            reduce using rule 19 (oprel -> LT .)
    SUB             reduce using rule 19 (oprel -> LT .)
    LITERAL_STR     reduce using rule 19 (oprel -> LT .)
    ID              reduce using rule 19 (oprel -> LT .)


state 65

    (20) oprel -> GT .

    INTEGER         reduce using rule 20 (oprel -> GT .)
    FLOAT           reduce using rule 20 (oprel -> GT .)
    LPAR            reduce using rule 20 (oprel -> GT .)
    SUB             reduce using rule 20 (oprel -> GT .)
    LITERAL_STR     reduce using rule 20 (oprel -> GT .)
    ID              reduce using rule 20 (oprel -> GT .)


state 66

    (21) oprel -> LEQ .

    INTEGER         reduce using rule 21 (oprel -> LEQ .)
    FLOAT           reduce using rule 21 (oprel -> LEQ .)
    LPAR            reduce using rule 21 (oprel -> LEQ .)
    SUB             reduce using rule 21 (oprel -> LEQ .)
    LITERAL_STR     reduce using rule 21 (oprel -> LEQ .)
    ID              reduce using rule 21 (oprel -> LEQ .)


state 67

    (22) oprel -> GEQ .

    INTEGER         reduce using rule 22 (oprel -> GEQ .)
    FLOAT           reduce using rule 22 (oprel -> GEQ .)
    LPAR            reduce using rule 22 (oprel -> GEQ .)
    SUB             reduce using rule 22 (oprel -> GEQ .)
    LITERAL_STR     reduce using rule 22 (oprel -> GEQ .)
    ID              reduce using rule 22 (oprel -> GEQ .)


state 68

    (12) block -> BEGIN stmt_list END .

    SEMICOLON       reduce using rule 12 (block -> BEGIN stmt_list END .)
    UNTIL           reduce using rule 12 (block -> BEGIN stmt_list END .)
    END             reduce using rule 12 (block -> BEGIN stmt_list END .)
    ELSE            reduce using rule 12 (block -> BEGIN stmt_list END .)


state 69

    (23) assignment -> ID arr_idx ASSIGN a_expr .
    (30) a_expr -> a_expr . a_op a_expr
    (37) a_op -> . ADD
    (38) a_op -> . SUB
    (39) a_op -> . MUL
    (40) a_op -> . DIV

    SEMICOLON       reduce using rule 23 (assignment -> ID arr_idx ASSIGN a_expr .)
    UNTIL           reduce using rule 23 (assignment -> ID arr_idx ASSIGN a_expr .)
    END             reduce using rule 23 (assignment -> ID arr_idx ASSIGN a_expr .)
    ELSE            reduce using rule 23 (assignment -> ID arr_idx ASSIGN a_expr .)
    ADD             shift and go to state 51
    SUB             shift and go to state 52
    MUL             shift and go to state 53
    DIV             shift and go to state 54

    a_op                           shift and go to state 50

state 70

    (42) arr_idx -> LBRACK a_expr RBRACK .

    ASSIGN          reduce using rule 42 (arr_idx -> LBRACK a_expr RBRACK .)
    COMMA           reduce using rule 42 (arr_idx -> LBRACK a_expr RBRACK .)
    SEMICOLON       reduce using rule 42 (arr_idx -> LBRACK a_expr RBRACK .)
    UNTIL           reduce using rule 42 (arr_idx -> LBRACK a_expr RBRACK .)
    END             reduce using rule 42 (arr_idx -> LBRACK a_expr RBRACK .)
    ELSE            reduce using rule 42 (arr_idx -> LBRACK a_expr RBRACK .)
    ADD             reduce using rule 42 (arr_idx -> LBRACK a_expr RBRACK .)
    SUB             reduce using rule 42 (arr_idx -> LBRACK a_expr RBRACK .)
    MUL             reduce using rule 42 (arr_idx -> LBRACK a_expr RBRACK .)
    DIV             reduce using rule 42 (arr_idx -> LBRACK a_expr RBRACK .)
    LT              reduce using rule 42 (arr_idx -> LBRACK a_expr RBRACK .)
    GT              reduce using rule 42 (arr_idx -> LBRACK a_expr RBRACK .)
    LEQ             reduce using rule 42 (arr_idx -> LBRACK a_expr RBRACK .)
    GEQ             reduce using rule 42 (arr_idx -> LBRACK a_expr RBRACK .)
    RBRACK          reduce using rule 42 (arr_idx -> LBRACK a_expr RBRACK .)
    RPAR            reduce using rule 42 (arr_idx -> LBRACK a_expr RBRACK .)
    ID              reduce using rule 42 (arr_idx -> LBRACK a_expr RBRACK .)
    READ            reduce using rule 42 (arr_idx -> LBRACK a_expr RBRACK .)
    WRITE           reduce using rule 42 (arr_idx -> LBRACK a_expr RBRACK .)
    WHILE           reduce using rule 42 (arr_idx -> LBRACK a_expr RBRACK .)
    REPEAT          reduce using rule 42 (arr_idx -> LBRACK a_expr RBRACK .)
    IF              reduce using rule 42 (arr_idx -> LBRACK a_expr RBRACK .)
    BEGIN           reduce using rule 42 (arr_idx -> LBRACK a_expr RBRACK .)
    DT_INT          reduce using rule 42 (arr_idx -> LBRACK a_expr RBRACK .)
    DT_FLOAT        reduce using rule 42 (arr_idx -> LBRACK a_expr RBRACK .)


state 71

    (45) varlist -> varlist COMMA varref .

    COMMA           reduce using rule 45 (varlist -> varlist COMMA varref .)
    SEMICOLON       reduce using rule 45 (varlist -> varlist COMMA varref .)
    UNTIL           reduce using rule 45 (varlist -> varlist COMMA varref .)
    END             reduce using rule 45 (varlist -> varlist COMMA varref .)
    ELSE            reduce using rule 45 (varlist -> varlist COMMA varref .)


state 72

    (47) expr_list -> expr_list COMMA a_expr .
    (30) a_expr -> a_expr . a_op a_expr
    (37) a_op -> . ADD
    (38) a_op -> . SUB
    (39) a_op -> . MUL
    (40) a_op -> . DIV

    COMMA           reduce using rule 47 (expr_list -> expr_list COMMA a_expr .)
    SEMICOLON       reduce using rule 47 (expr_list -> expr_list COMMA a_expr .)
    UNTIL           reduce using rule 47 (expr_list -> expr_list COMMA a_expr .)
    END             reduce using rule 47 (expr_list -> expr_list COMMA a_expr .)
    ELSE            reduce using rule 47 (expr_list -> expr_list COMMA a_expr .)
    ADD             shift and go to state 51
    SUB             shift and go to state 52
    MUL             shift and go to state 53
    DIV             shift and go to state 54

    a_op                           shift and go to state 50

state 73

    (30) a_expr -> a_expr a_op a_expr .
    (30) a_expr -> a_expr . a_op a_expr
    (37) a_op -> . ADD
    (38) a_op -> . SUB
    (39) a_op -> . MUL
    (40) a_op -> . DIV

  ! shift/reduce conflict for ADD resolved as shift
  ! shift/reduce conflict for SUB resolved as shift
  ! shift/reduce conflict for MUL resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
    COMMA           reduce using rule 30 (a_expr -> a_expr a_op a_expr .)
    SEMICOLON       reduce using rule 30 (a_expr -> a_expr a_op a_expr .)
    UNTIL           reduce using rule 30 (a_expr -> a_expr a_op a_expr .)
    END             reduce using rule 30 (a_expr -> a_expr a_op a_expr .)
    ELSE            reduce using rule 30 (a_expr -> a_expr a_op a_expr .)
    LT              reduce using rule 30 (a_expr -> a_expr a_op a_expr .)
    GT              reduce using rule 30 (a_expr -> a_expr a_op a_expr .)
    LEQ             reduce using rule 30 (a_expr -> a_expr a_op a_expr .)
    GEQ             reduce using rule 30 (a_expr -> a_expr a_op a_expr .)
    RBRACK          reduce using rule 30 (a_expr -> a_expr a_op a_expr .)
    RPAR            reduce using rule 30 (a_expr -> a_expr a_op a_expr .)
    ID              reduce using rule 30 (a_expr -> a_expr a_op a_expr .)
    READ            reduce using rule 30 (a_expr -> a_expr a_op a_expr .)
    WRITE           reduce using rule 30 (a_expr -> a_expr a_op a_expr .)
    WHILE           reduce using rule 30 (a_expr -> a_expr a_op a_expr .)
    REPEAT          reduce using rule 30 (a_expr -> a_expr a_op a_expr .)
    IF              reduce using rule 30 (a_expr -> a_expr a_op a_expr .)
    BEGIN           reduce using rule 30 (a_expr -> a_expr a_op a_expr .)
    DT_INT          reduce using rule 30 (a_expr -> a_expr a_op a_expr .)
    DT_FLOAT        reduce using rule 30 (a_expr -> a_expr a_op a_expr .)
    ADD             shift and go to state 51
    SUB             shift and go to state 52
    MUL             shift and go to state 53
    DIV             shift and go to state 54

  ! ADD             [ reduce using rule 30 (a_expr -> a_expr a_op a_expr .) ]
  ! SUB             [ reduce using rule 30 (a_expr -> a_expr a_op a_expr .) ]
  ! MUL             [ reduce using rule 30 (a_expr -> a_expr a_op a_expr .) ]
  ! DIV             [ reduce using rule 30 (a_expr -> a_expr a_op a_expr .) ]

    a_op                           shift and go to state 50

state 74

    (34) a_expr -> LPAR a_expr RPAR .

    ADD             reduce using rule 34 (a_expr -> LPAR a_expr RPAR .)
    SUB             reduce using rule 34 (a_expr -> LPAR a_expr RPAR .)
    MUL             reduce using rule 34 (a_expr -> LPAR a_expr RPAR .)
    DIV             reduce using rule 34 (a_expr -> LPAR a_expr RPAR .)
    COMMA           reduce using rule 34 (a_expr -> LPAR a_expr RPAR .)
    SEMICOLON       reduce using rule 34 (a_expr -> LPAR a_expr RPAR .)
    UNTIL           reduce using rule 34 (a_expr -> LPAR a_expr RPAR .)
    END             reduce using rule 34 (a_expr -> LPAR a_expr RPAR .)
    ELSE            reduce using rule 34 (a_expr -> LPAR a_expr RPAR .)
    LT              reduce using rule 34 (a_expr -> LPAR a_expr RPAR .)
    GT              reduce using rule 34 (a_expr -> LPAR a_expr RPAR .)
    LEQ             reduce using rule 34 (a_expr -> LPAR a_expr RPAR .)
    GEQ             reduce using rule 34 (a_expr -> LPAR a_expr RPAR .)
    RBRACK          reduce using rule 34 (a_expr -> LPAR a_expr RPAR .)
    RPAR            reduce using rule 34 (a_expr -> LPAR a_expr RPAR .)
    ID              reduce using rule 34 (a_expr -> LPAR a_expr RPAR .)
    READ            reduce using rule 34 (a_expr -> LPAR a_expr RPAR .)
    WRITE           reduce using rule 34 (a_expr -> LPAR a_expr RPAR .)
    WHILE           reduce using rule 34 (a_expr -> LPAR a_expr RPAR .)
    REPEAT          reduce using rule 34 (a_expr -> LPAR a_expr RPAR .)
    IF              reduce using rule 34 (a_expr -> LPAR a_expr RPAR .)
    BEGIN           reduce using rule 34 (a_expr -> LPAR a_expr RPAR .)
    DT_INT          reduce using rule 34 (a_expr -> LPAR a_expr RPAR .)
    DT_FLOAT        reduce using rule 34 (a_expr -> LPAR a_expr RPAR .)


state 75

    (26) arr_size -> LBRACK a_expr . RBRACK
    (30) a_expr -> a_expr . a_op a_expr
    (37) a_op -> . ADD
    (38) a_op -> . SUB
    (39) a_op -> . MUL
    (40) a_op -> . DIV

    RBRACK          shift and go to state 81
    ADD             shift and go to state 51
    SUB             shift and go to state 52
    MUL             shift and go to state 53
    DIV             shift and go to state 54

    a_op                           shift and go to state 50

state 76

    (13) construct_while -> WHILE LPAR l_expr RPAR . DO block

    DO              shift and go to state 82


state 77

    (14) construct_repeat -> REPEAT stmt_list UNTIL LPAR . l_expr RPAR
    (18) l_expr -> . a_expr oprel a_expr
    (30) a_expr -> . a_expr a_op a_expr
    (31) a_expr -> . varref
    (32) a_expr -> . INTEGER
    (33) a_expr -> . FLOAT
    (34) a_expr -> . LPAR a_expr RPAR
    (35) a_expr -> . SUB a_expr
    (36) a_expr -> . LITERAL_STR
    (41) varref -> . ID arr_idx

    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 33
    LPAR            shift and go to state 34
    SUB             shift and go to state 35
    LITERAL_STR     shift and go to state 36
    ID              shift and go to state 28

    l_expr                         shift and go to state 83
    a_expr                         shift and go to state 41
    varref                         shift and go to state 31

state 78

    (15) construct_if -> IF l_expr stmt construct_else .

    SEMICOLON       reduce using rule 15 (construct_if -> IF l_expr stmt construct_else .)
    UNTIL           reduce using rule 15 (construct_if -> IF l_expr stmt construct_else .)
    END             reduce using rule 15 (construct_if -> IF l_expr stmt construct_else .)
    ELSE            reduce using rule 15 (construct_if -> IF l_expr stmt construct_else .)


state 79

    (17) construct_else -> ELSE . stmt
    (4) stmt -> . assignment
    (5) stmt -> . read
    (6) stmt -> . write
    (7) stmt -> . declaration
    (8) stmt -> . construct_while
    (9) stmt -> . construct_repeat
    (10) stmt -> . construct_if
    (11) stmt -> . block
    (23) assignment -> . ID arr_idx ASSIGN a_expr
    (24) assignment -> . ID ASSIGN a_expr
    (43) read -> . READ varlist
    (44) write -> . WRITE expr_list
    (25) declaration -> . datatype ID arr_size
    (13) construct_while -> . WHILE LPAR l_expr RPAR DO block
    (14) construct_repeat -> . REPEAT stmt_list UNTIL LPAR l_expr RPAR
    (15) construct_if -> . IF l_expr stmt construct_else
    (12) block -> . BEGIN stmt_list END
    (28) datatype -> . DT_INT
    (29) datatype -> . DT_FLOAT

    ID              shift and go to state 12
    READ            shift and go to state 13
    WRITE           shift and go to state 14
    WHILE           shift and go to state 16
    REPEAT          shift and go to state 17
    IF              shift and go to state 18
    BEGIN           shift and go to state 19
    DT_INT          shift and go to state 20
    DT_FLOAT        shift and go to state 21

    stmt                           shift and go to state 84
    assignment                     shift and go to state 4
    read                           shift and go to state 5
    write                          shift and go to state 6
    declaration                    shift and go to state 7
    construct_while                shift and go to state 8
    construct_repeat               shift and go to state 9
    construct_if                   shift and go to state 10
    block                          shift and go to state 11
    datatype                       shift and go to state 15

state 80

    (18) l_expr -> a_expr oprel a_expr .
    (30) a_expr -> a_expr . a_op a_expr
    (37) a_op -> . ADD
    (38) a_op -> . SUB
    (39) a_op -> . MUL
    (40) a_op -> . DIV

    ID              reduce using rule 18 (l_expr -> a_expr oprel a_expr .)
    READ            reduce using rule 18 (l_expr -> a_expr oprel a_expr .)
    WRITE           reduce using rule 18 (l_expr -> a_expr oprel a_expr .)
    WHILE           reduce using rule 18 (l_expr -> a_expr oprel a_expr .)
    REPEAT          reduce using rule 18 (l_expr -> a_expr oprel a_expr .)
    IF              reduce using rule 18 (l_expr -> a_expr oprel a_expr .)
    BEGIN           reduce using rule 18 (l_expr -> a_expr oprel a_expr .)
    DT_INT          reduce using rule 18 (l_expr -> a_expr oprel a_expr .)
    DT_FLOAT        reduce using rule 18 (l_expr -> a_expr oprel a_expr .)
    RPAR            reduce using rule 18 (l_expr -> a_expr oprel a_expr .)
    ADD             shift and go to state 51
    SUB             shift and go to state 52
    MUL             shift and go to state 53
    DIV             shift and go to state 54

    a_op                           shift and go to state 50

state 81

    (26) arr_size -> LBRACK a_expr RBRACK .

    SEMICOLON       reduce using rule 26 (arr_size -> LBRACK a_expr RBRACK .)
    UNTIL           reduce using rule 26 (arr_size -> LBRACK a_expr RBRACK .)
    END             reduce using rule 26 (arr_size -> LBRACK a_expr RBRACK .)
    ELSE            reduce using rule 26 (arr_size -> LBRACK a_expr RBRACK .)


state 82

    (13) construct_while -> WHILE LPAR l_expr RPAR DO . block
    (12) block -> . BEGIN stmt_list END

    BEGIN           shift and go to state 19

    block                          shift and go to state 85

state 83

    (14) construct_repeat -> REPEAT stmt_list UNTIL LPAR l_expr . RPAR

    RPAR            shift and go to state 86


state 84

    (17) construct_else -> ELSE stmt .

    ELSE            reduce using rule 17 (construct_else -> ELSE stmt .)
    SEMICOLON       reduce using rule 17 (construct_else -> ELSE stmt .)
    UNTIL           reduce using rule 17 (construct_else -> ELSE stmt .)
    END             reduce using rule 17 (construct_else -> ELSE stmt .)


state 85

    (13) construct_while -> WHILE LPAR l_expr RPAR DO block .

    SEMICOLON       reduce using rule 13 (construct_while -> WHILE LPAR l_expr RPAR DO block .)
    UNTIL           reduce using rule 13 (construct_while -> WHILE LPAR l_expr RPAR DO block .)
    END             reduce using rule 13 (construct_while -> WHILE LPAR l_expr RPAR DO block .)
    ELSE            reduce using rule 13 (construct_while -> WHILE LPAR l_expr RPAR DO block .)


state 86

    (14) construct_repeat -> REPEAT stmt_list UNTIL LPAR l_expr RPAR .

    SEMICOLON       reduce using rule 14 (construct_repeat -> REPEAT stmt_list UNTIL LPAR l_expr RPAR .)
    UNTIL           reduce using rule 14 (construct_repeat -> REPEAT stmt_list UNTIL LPAR l_expr RPAR .)
    END             reduce using rule 14 (construct_repeat -> REPEAT stmt_list UNTIL LPAR l_expr RPAR .)
    ELSE            reduce using rule 14 (construct_repeat -> REPEAT stmt_list UNTIL LPAR l_expr RPAR .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ADD in state 56 resolved as shift
WARNING: shift/reduce conflict for SUB in state 56 resolved as shift
WARNING: shift/reduce conflict for MUL in state 56 resolved as shift
WARNING: shift/reduce conflict for DIV in state 56 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 62 resolved as shift
WARNING: shift/reduce conflict for ADD in state 73 resolved as shift
WARNING: shift/reduce conflict for SUB in state 73 resolved as shift
WARNING: shift/reduce conflict for MUL in state 73 resolved as shift
WARNING: shift/reduce conflict for DIV in state 73 resolved as shift
