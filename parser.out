Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    BEGIN
    END
    THEN

Grammar

Rule 0     S' -> program
Rule 1     program -> stmt_list SEMICOLON
Rule 2     stmt_list -> stmt_list SEMICOLON stmt
Rule 3     stmt_list -> stmt
Rule 4     stmt -> assignment
Rule 5     stmt -> read
Rule 6     stmt -> write
Rule 7     stmt -> declaration
Rule 8     stmt -> construct_while
Rule 9     stmt -> construct_repeat
Rule 10    stmt -> construct_if
Rule 11    construct_while -> WHILE LPAR l_expr RPAR DO stmt
Rule 12    construct_repeat -> REPEAT stmt_list UNTIL LPAR l_expr RPAR
Rule 13    construct_if -> IF LPAR l_expr RPAR stmt construct_else
Rule 14    construct_else -> <empty>
Rule 15    construct_else -> ELSE stmt
Rule 16    l_expr -> a_expr oprel a_expr
Rule 17    oprel -> LT
Rule 18    oprel -> GT
Rule 19    oprel -> LEQ
Rule 20    oprel -> GEQ
Rule 21    assignment -> ID arr_idx ASSIGN a_expr
Rule 22    declaration -> datatype ID arr_size
Rule 23    arr_size -> LBRACK a_expr RBRACK
Rule 24    arr_size -> <empty>
Rule 25    datatype -> DT_INT
Rule 26    datatype -> DT_FLOAT
Rule 27    a_expr -> a_expr a_op a_expr
Rule 28    a_expr -> varref
Rule 29    a_expr -> INTEGER
Rule 30    a_expr -> FLOAT
Rule 31    a_expr -> LPAR a_expr RPAR
Rule 32    a_expr -> SUB a_expr
Rule 33    a_expr -> LITERAL_STR
Rule 34    a_op -> ADD
Rule 35    a_op -> SUB
Rule 36    a_op -> MUL
Rule 37    a_op -> DIV
Rule 38    varref -> ID arr_idx
Rule 39    arr_idx -> LBRACK a_expr RBRACK
Rule 40    read -> READ varlist
Rule 41    write -> WRITE expr_list
Rule 42    varlist -> varlist COMMA varref
Rule 43    varlist -> varref
Rule 44    expr_list -> expr_list COMMA a_expr
Rule 45    expr_list -> a_expr

Terminals, with rules where they appear

ADD                  : 34
ASSIGN               : 21
BEGIN                : 
COMMA                : 42 44
DIV                  : 37
DO                   : 11
DT_FLOAT             : 26
DT_INT               : 25
ELSE                 : 15
END                  : 
FLOAT                : 30
GEQ                  : 20
GT                   : 18
ID                   : 21 22 38
IF                   : 13
INTEGER              : 29
LBRACK               : 23 39
LEQ                  : 19
LITERAL_STR          : 33
LPAR                 : 11 12 13 31
LT                   : 17
MUL                  : 36
RBRACK               : 23 39
READ                 : 40
REPEAT               : 12
RPAR                 : 11 12 13 31
SEMICOLON            : 1 2
SUB                  : 32 35
THEN                 : 
UNTIL                : 12
WHILE                : 11
WRITE                : 41
error                : 

Nonterminals, with rules where they appear

a_expr               : 16 16 21 23 27 27 31 32 39 44 45
a_op                 : 27
arr_idx              : 21 38
arr_size             : 22
assignment           : 4
construct_else       : 13
construct_if         : 10
construct_repeat     : 9
construct_while      : 8
datatype             : 22
declaration          : 7
expr_list            : 41 44
l_expr               : 11 12 13
oprel                : 16
program              : 0
read                 : 5
stmt                 : 2 3 11 13 15
stmt_list            : 1 2 12
varlist              : 40 42
varref               : 28 42 43
write                : 6

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . stmt_list SEMICOLON
    (2) stmt_list -> . stmt_list SEMICOLON stmt
    (3) stmt_list -> . stmt
    (4) stmt -> . assignment
    (5) stmt -> . read
    (6) stmt -> . write
    (7) stmt -> . declaration
    (8) stmt -> . construct_while
    (9) stmt -> . construct_repeat
    (10) stmt -> . construct_if
    (21) assignment -> . ID arr_idx ASSIGN a_expr
    (40) read -> . READ varlist
    (41) write -> . WRITE expr_list
    (22) declaration -> . datatype ID arr_size
    (11) construct_while -> . WHILE LPAR l_expr RPAR DO stmt
    (12) construct_repeat -> . REPEAT stmt_list UNTIL LPAR l_expr RPAR
    (13) construct_if -> . IF LPAR l_expr RPAR stmt construct_else
    (25) datatype -> . DT_INT
    (26) datatype -> . DT_FLOAT

    ID              shift and go to state 11
    READ            shift and go to state 12
    WRITE           shift and go to state 13
    WHILE           shift and go to state 15
    REPEAT          shift and go to state 16
    IF              shift and go to state 17
    DT_INT          shift and go to state 18
    DT_FLOAT        shift and go to state 19

    program                        shift and go to state 1
    stmt_list                      shift and go to state 2
    stmt                           shift and go to state 3
    assignment                     shift and go to state 4
    read                           shift and go to state 5
    write                          shift and go to state 6
    declaration                    shift and go to state 7
    construct_while                shift and go to state 8
    construct_repeat               shift and go to state 9
    construct_if                   shift and go to state 10
    datatype                       shift and go to state 14

state 1

    (0) S' -> program .



state 2

    (1) program -> stmt_list . SEMICOLON
    (2) stmt_list -> stmt_list . SEMICOLON stmt

    SEMICOLON       shift and go to state 20


state 3

    (3) stmt_list -> stmt .

    SEMICOLON       reduce using rule 3 (stmt_list -> stmt .)
    UNTIL           reduce using rule 3 (stmt_list -> stmt .)


state 4

    (4) stmt -> assignment .

    SEMICOLON       reduce using rule 4 (stmt -> assignment .)
    UNTIL           reduce using rule 4 (stmt -> assignment .)
    ELSE            reduce using rule 4 (stmt -> assignment .)


state 5

    (5) stmt -> read .

    SEMICOLON       reduce using rule 5 (stmt -> read .)
    UNTIL           reduce using rule 5 (stmt -> read .)
    ELSE            reduce using rule 5 (stmt -> read .)


state 6

    (6) stmt -> write .

    SEMICOLON       reduce using rule 6 (stmt -> write .)
    UNTIL           reduce using rule 6 (stmt -> write .)
    ELSE            reduce using rule 6 (stmt -> write .)


state 7

    (7) stmt -> declaration .

    SEMICOLON       reduce using rule 7 (stmt -> declaration .)
    UNTIL           reduce using rule 7 (stmt -> declaration .)
    ELSE            reduce using rule 7 (stmt -> declaration .)


state 8

    (8) stmt -> construct_while .

    SEMICOLON       reduce using rule 8 (stmt -> construct_while .)
    UNTIL           reduce using rule 8 (stmt -> construct_while .)
    ELSE            reduce using rule 8 (stmt -> construct_while .)


state 9

    (9) stmt -> construct_repeat .

    SEMICOLON       reduce using rule 9 (stmt -> construct_repeat .)
    UNTIL           reduce using rule 9 (stmt -> construct_repeat .)
    ELSE            reduce using rule 9 (stmt -> construct_repeat .)


state 10

    (10) stmt -> construct_if .

    SEMICOLON       reduce using rule 10 (stmt -> construct_if .)
    UNTIL           reduce using rule 10 (stmt -> construct_if .)
    ELSE            reduce using rule 10 (stmt -> construct_if .)


state 11

    (21) assignment -> ID . arr_idx ASSIGN a_expr
    (39) arr_idx -> . LBRACK a_expr RBRACK

    LBRACK          shift and go to state 22

    arr_idx                        shift and go to state 21

state 12

    (40) read -> READ . varlist
    (42) varlist -> . varlist COMMA varref
    (43) varlist -> . varref
    (38) varref -> . ID arr_idx

    ID              shift and go to state 25

    varlist                        shift and go to state 23
    varref                         shift and go to state 24

state 13

    (41) write -> WRITE . expr_list
    (44) expr_list -> . expr_list COMMA a_expr
    (45) expr_list -> . a_expr
    (27) a_expr -> . a_expr a_op a_expr
    (28) a_expr -> . varref
    (29) a_expr -> . INTEGER
    (30) a_expr -> . FLOAT
    (31) a_expr -> . LPAR a_expr RPAR
    (32) a_expr -> . SUB a_expr
    (33) a_expr -> . LITERAL_STR
    (38) varref -> . ID arr_idx

    INTEGER         shift and go to state 29
    FLOAT           shift and go to state 30
    LPAR            shift and go to state 31
    SUB             shift and go to state 32
    LITERAL_STR     shift and go to state 33
    ID              shift and go to state 25

    expr_list                      shift and go to state 26
    a_expr                         shift and go to state 27
    varref                         shift and go to state 28

state 14

    (22) declaration -> datatype . ID arr_size

    ID              shift and go to state 34


state 15

    (11) construct_while -> WHILE . LPAR l_expr RPAR DO stmt

    LPAR            shift and go to state 35


state 16

    (12) construct_repeat -> REPEAT . stmt_list UNTIL LPAR l_expr RPAR
    (2) stmt_list -> . stmt_list SEMICOLON stmt
    (3) stmt_list -> . stmt
    (4) stmt -> . assignment
    (5) stmt -> . read
    (6) stmt -> . write
    (7) stmt -> . declaration
    (8) stmt -> . construct_while
    (9) stmt -> . construct_repeat
    (10) stmt -> . construct_if
    (21) assignment -> . ID arr_idx ASSIGN a_expr
    (40) read -> . READ varlist
    (41) write -> . WRITE expr_list
    (22) declaration -> . datatype ID arr_size
    (11) construct_while -> . WHILE LPAR l_expr RPAR DO stmt
    (12) construct_repeat -> . REPEAT stmt_list UNTIL LPAR l_expr RPAR
    (13) construct_if -> . IF LPAR l_expr RPAR stmt construct_else
    (25) datatype -> . DT_INT
    (26) datatype -> . DT_FLOAT

    ID              shift and go to state 11
    READ            shift and go to state 12
    WRITE           shift and go to state 13
    WHILE           shift and go to state 15
    REPEAT          shift and go to state 16
    IF              shift and go to state 17
    DT_INT          shift and go to state 18
    DT_FLOAT        shift and go to state 19

    stmt_list                      shift and go to state 36
    stmt                           shift and go to state 3
    assignment                     shift and go to state 4
    read                           shift and go to state 5
    write                          shift and go to state 6
    declaration                    shift and go to state 7
    construct_while                shift and go to state 8
    construct_repeat               shift and go to state 9
    construct_if                   shift and go to state 10
    datatype                       shift and go to state 14

state 17

    (13) construct_if -> IF . LPAR l_expr RPAR stmt construct_else

    LPAR            shift and go to state 37


state 18

    (25) datatype -> DT_INT .

    ID              reduce using rule 25 (datatype -> DT_INT .)


state 19

    (26) datatype -> DT_FLOAT .

    ID              reduce using rule 26 (datatype -> DT_FLOAT .)


state 20

    (1) program -> stmt_list SEMICOLON .
    (2) stmt_list -> stmt_list SEMICOLON . stmt
    (4) stmt -> . assignment
    (5) stmt -> . read
    (6) stmt -> . write
    (7) stmt -> . declaration
    (8) stmt -> . construct_while
    (9) stmt -> . construct_repeat
    (10) stmt -> . construct_if
    (21) assignment -> . ID arr_idx ASSIGN a_expr
    (40) read -> . READ varlist
    (41) write -> . WRITE expr_list
    (22) declaration -> . datatype ID arr_size
    (11) construct_while -> . WHILE LPAR l_expr RPAR DO stmt
    (12) construct_repeat -> . REPEAT stmt_list UNTIL LPAR l_expr RPAR
    (13) construct_if -> . IF LPAR l_expr RPAR stmt construct_else
    (25) datatype -> . DT_INT
    (26) datatype -> . DT_FLOAT

    $end            reduce using rule 1 (program -> stmt_list SEMICOLON .)
    ID              shift and go to state 11
    READ            shift and go to state 12
    WRITE           shift and go to state 13
    WHILE           shift and go to state 15
    REPEAT          shift and go to state 16
    IF              shift and go to state 17
    DT_INT          shift and go to state 18
    DT_FLOAT        shift and go to state 19

    stmt                           shift and go to state 38
    assignment                     shift and go to state 4
    read                           shift and go to state 5
    write                          shift and go to state 6
    declaration                    shift and go to state 7
    construct_while                shift and go to state 8
    construct_repeat               shift and go to state 9
    construct_if                   shift and go to state 10
    datatype                       shift and go to state 14

state 21

    (21) assignment -> ID arr_idx . ASSIGN a_expr

    ASSIGN          shift and go to state 39


state 22

    (39) arr_idx -> LBRACK . a_expr RBRACK
    (27) a_expr -> . a_expr a_op a_expr
    (28) a_expr -> . varref
    (29) a_expr -> . INTEGER
    (30) a_expr -> . FLOAT
    (31) a_expr -> . LPAR a_expr RPAR
    (32) a_expr -> . SUB a_expr
    (33) a_expr -> . LITERAL_STR
    (38) varref -> . ID arr_idx

    INTEGER         shift and go to state 29
    FLOAT           shift and go to state 30
    LPAR            shift and go to state 31
    SUB             shift and go to state 32
    LITERAL_STR     shift and go to state 33
    ID              shift and go to state 25

    a_expr                         shift and go to state 40
    varref                         shift and go to state 28

state 23

    (40) read -> READ varlist .
    (42) varlist -> varlist . COMMA varref

    SEMICOLON       reduce using rule 40 (read -> READ varlist .)
    UNTIL           reduce using rule 40 (read -> READ varlist .)
    ELSE            reduce using rule 40 (read -> READ varlist .)
    COMMA           shift and go to state 41


state 24

    (43) varlist -> varref .

    COMMA           reduce using rule 43 (varlist -> varref .)
    SEMICOLON       reduce using rule 43 (varlist -> varref .)
    UNTIL           reduce using rule 43 (varlist -> varref .)
    ELSE            reduce using rule 43 (varlist -> varref .)


state 25

    (38) varref -> ID . arr_idx
    (39) arr_idx -> . LBRACK a_expr RBRACK

    LBRACK          shift and go to state 22

    arr_idx                        shift and go to state 42

state 26

    (41) write -> WRITE expr_list .
    (44) expr_list -> expr_list . COMMA a_expr

    SEMICOLON       reduce using rule 41 (write -> WRITE expr_list .)
    UNTIL           reduce using rule 41 (write -> WRITE expr_list .)
    ELSE            reduce using rule 41 (write -> WRITE expr_list .)
    COMMA           shift and go to state 43


state 27

    (45) expr_list -> a_expr .
    (27) a_expr -> a_expr . a_op a_expr
    (34) a_op -> . ADD
    (35) a_op -> . SUB
    (36) a_op -> . MUL
    (37) a_op -> . DIV

    COMMA           reduce using rule 45 (expr_list -> a_expr .)
    SEMICOLON       reduce using rule 45 (expr_list -> a_expr .)
    UNTIL           reduce using rule 45 (expr_list -> a_expr .)
    ELSE            reduce using rule 45 (expr_list -> a_expr .)
    ADD             shift and go to state 45
    SUB             shift and go to state 46
    MUL             shift and go to state 47
    DIV             shift and go to state 48

    a_op                           shift and go to state 44

state 28

    (28) a_expr -> varref .

    ADD             reduce using rule 28 (a_expr -> varref .)
    SUB             reduce using rule 28 (a_expr -> varref .)
    MUL             reduce using rule 28 (a_expr -> varref .)
    DIV             reduce using rule 28 (a_expr -> varref .)
    COMMA           reduce using rule 28 (a_expr -> varref .)
    SEMICOLON       reduce using rule 28 (a_expr -> varref .)
    UNTIL           reduce using rule 28 (a_expr -> varref .)
    ELSE            reduce using rule 28 (a_expr -> varref .)
    RBRACK          reduce using rule 28 (a_expr -> varref .)
    RPAR            reduce using rule 28 (a_expr -> varref .)
    LT              reduce using rule 28 (a_expr -> varref .)
    GT              reduce using rule 28 (a_expr -> varref .)
    LEQ             reduce using rule 28 (a_expr -> varref .)
    GEQ             reduce using rule 28 (a_expr -> varref .)


state 29

    (29) a_expr -> INTEGER .

    ADD             reduce using rule 29 (a_expr -> INTEGER .)
    SUB             reduce using rule 29 (a_expr -> INTEGER .)
    MUL             reduce using rule 29 (a_expr -> INTEGER .)
    DIV             reduce using rule 29 (a_expr -> INTEGER .)
    COMMA           reduce using rule 29 (a_expr -> INTEGER .)
    SEMICOLON       reduce using rule 29 (a_expr -> INTEGER .)
    UNTIL           reduce using rule 29 (a_expr -> INTEGER .)
    ELSE            reduce using rule 29 (a_expr -> INTEGER .)
    RBRACK          reduce using rule 29 (a_expr -> INTEGER .)
    RPAR            reduce using rule 29 (a_expr -> INTEGER .)
    LT              reduce using rule 29 (a_expr -> INTEGER .)
    GT              reduce using rule 29 (a_expr -> INTEGER .)
    LEQ             reduce using rule 29 (a_expr -> INTEGER .)
    GEQ             reduce using rule 29 (a_expr -> INTEGER .)


state 30

    (30) a_expr -> FLOAT .

    ADD             reduce using rule 30 (a_expr -> FLOAT .)
    SUB             reduce using rule 30 (a_expr -> FLOAT .)
    MUL             reduce using rule 30 (a_expr -> FLOAT .)
    DIV             reduce using rule 30 (a_expr -> FLOAT .)
    COMMA           reduce using rule 30 (a_expr -> FLOAT .)
    SEMICOLON       reduce using rule 30 (a_expr -> FLOAT .)
    UNTIL           reduce using rule 30 (a_expr -> FLOAT .)
    ELSE            reduce using rule 30 (a_expr -> FLOAT .)
    RBRACK          reduce using rule 30 (a_expr -> FLOAT .)
    RPAR            reduce using rule 30 (a_expr -> FLOAT .)
    LT              reduce using rule 30 (a_expr -> FLOAT .)
    GT              reduce using rule 30 (a_expr -> FLOAT .)
    LEQ             reduce using rule 30 (a_expr -> FLOAT .)
    GEQ             reduce using rule 30 (a_expr -> FLOAT .)


state 31

    (31) a_expr -> LPAR . a_expr RPAR
    (27) a_expr -> . a_expr a_op a_expr
    (28) a_expr -> . varref
    (29) a_expr -> . INTEGER
    (30) a_expr -> . FLOAT
    (31) a_expr -> . LPAR a_expr RPAR
    (32) a_expr -> . SUB a_expr
    (33) a_expr -> . LITERAL_STR
    (38) varref -> . ID arr_idx

    INTEGER         shift and go to state 29
    FLOAT           shift and go to state 30
    LPAR            shift and go to state 31
    SUB             shift and go to state 32
    LITERAL_STR     shift and go to state 33
    ID              shift and go to state 25

    a_expr                         shift and go to state 49
    varref                         shift and go to state 28

state 32

    (32) a_expr -> SUB . a_expr
    (27) a_expr -> . a_expr a_op a_expr
    (28) a_expr -> . varref
    (29) a_expr -> . INTEGER
    (30) a_expr -> . FLOAT
    (31) a_expr -> . LPAR a_expr RPAR
    (32) a_expr -> . SUB a_expr
    (33) a_expr -> . LITERAL_STR
    (38) varref -> . ID arr_idx

    INTEGER         shift and go to state 29
    FLOAT           shift and go to state 30
    LPAR            shift and go to state 31
    SUB             shift and go to state 32
    LITERAL_STR     shift and go to state 33
    ID              shift and go to state 25

    a_expr                         shift and go to state 50
    varref                         shift and go to state 28

state 33

    (33) a_expr -> LITERAL_STR .

    ADD             reduce using rule 33 (a_expr -> LITERAL_STR .)
    SUB             reduce using rule 33 (a_expr -> LITERAL_STR .)
    MUL             reduce using rule 33 (a_expr -> LITERAL_STR .)
    DIV             reduce using rule 33 (a_expr -> LITERAL_STR .)
    COMMA           reduce using rule 33 (a_expr -> LITERAL_STR .)
    SEMICOLON       reduce using rule 33 (a_expr -> LITERAL_STR .)
    UNTIL           reduce using rule 33 (a_expr -> LITERAL_STR .)
    ELSE            reduce using rule 33 (a_expr -> LITERAL_STR .)
    RBRACK          reduce using rule 33 (a_expr -> LITERAL_STR .)
    RPAR            reduce using rule 33 (a_expr -> LITERAL_STR .)
    LT              reduce using rule 33 (a_expr -> LITERAL_STR .)
    GT              reduce using rule 33 (a_expr -> LITERAL_STR .)
    LEQ             reduce using rule 33 (a_expr -> LITERAL_STR .)
    GEQ             reduce using rule 33 (a_expr -> LITERAL_STR .)


state 34

    (22) declaration -> datatype ID . arr_size
    (23) arr_size -> . LBRACK a_expr RBRACK
    (24) arr_size -> .

    LBRACK          shift and go to state 52
    SEMICOLON       reduce using rule 24 (arr_size -> .)
    UNTIL           reduce using rule 24 (arr_size -> .)
    ELSE            reduce using rule 24 (arr_size -> .)

    arr_size                       shift and go to state 51

state 35

    (11) construct_while -> WHILE LPAR . l_expr RPAR DO stmt
    (16) l_expr -> . a_expr oprel a_expr
    (27) a_expr -> . a_expr a_op a_expr
    (28) a_expr -> . varref
    (29) a_expr -> . INTEGER
    (30) a_expr -> . FLOAT
    (31) a_expr -> . LPAR a_expr RPAR
    (32) a_expr -> . SUB a_expr
    (33) a_expr -> . LITERAL_STR
    (38) varref -> . ID arr_idx

    INTEGER         shift and go to state 29
    FLOAT           shift and go to state 30
    LPAR            shift and go to state 31
    SUB             shift and go to state 32
    LITERAL_STR     shift and go to state 33
    ID              shift and go to state 25

    l_expr                         shift and go to state 53
    a_expr                         shift and go to state 54
    varref                         shift and go to state 28

state 36

    (12) construct_repeat -> REPEAT stmt_list . UNTIL LPAR l_expr RPAR
    (2) stmt_list -> stmt_list . SEMICOLON stmt

    UNTIL           shift and go to state 55
    SEMICOLON       shift and go to state 56


state 37

    (13) construct_if -> IF LPAR . l_expr RPAR stmt construct_else
    (16) l_expr -> . a_expr oprel a_expr
    (27) a_expr -> . a_expr a_op a_expr
    (28) a_expr -> . varref
    (29) a_expr -> . INTEGER
    (30) a_expr -> . FLOAT
    (31) a_expr -> . LPAR a_expr RPAR
    (32) a_expr -> . SUB a_expr
    (33) a_expr -> . LITERAL_STR
    (38) varref -> . ID arr_idx

    INTEGER         shift and go to state 29
    FLOAT           shift and go to state 30
    LPAR            shift and go to state 31
    SUB             shift and go to state 32
    LITERAL_STR     shift and go to state 33
    ID              shift and go to state 25

    l_expr                         shift and go to state 57
    a_expr                         shift and go to state 54
    varref                         shift and go to state 28

state 38

    (2) stmt_list -> stmt_list SEMICOLON stmt .

    SEMICOLON       reduce using rule 2 (stmt_list -> stmt_list SEMICOLON stmt .)
    UNTIL           reduce using rule 2 (stmt_list -> stmt_list SEMICOLON stmt .)


state 39

    (21) assignment -> ID arr_idx ASSIGN . a_expr
    (27) a_expr -> . a_expr a_op a_expr
    (28) a_expr -> . varref
    (29) a_expr -> . INTEGER
    (30) a_expr -> . FLOAT
    (31) a_expr -> . LPAR a_expr RPAR
    (32) a_expr -> . SUB a_expr
    (33) a_expr -> . LITERAL_STR
    (38) varref -> . ID arr_idx

    INTEGER         shift and go to state 29
    FLOAT           shift and go to state 30
    LPAR            shift and go to state 31
    SUB             shift and go to state 32
    LITERAL_STR     shift and go to state 33
    ID              shift and go to state 25

    a_expr                         shift and go to state 58
    varref                         shift and go to state 28

state 40

    (39) arr_idx -> LBRACK a_expr . RBRACK
    (27) a_expr -> a_expr . a_op a_expr
    (34) a_op -> . ADD
    (35) a_op -> . SUB
    (36) a_op -> . MUL
    (37) a_op -> . DIV

    RBRACK          shift and go to state 59
    ADD             shift and go to state 45
    SUB             shift and go to state 46
    MUL             shift and go to state 47
    DIV             shift and go to state 48

    a_op                           shift and go to state 44

state 41

    (42) varlist -> varlist COMMA . varref
    (38) varref -> . ID arr_idx

    ID              shift and go to state 25

    varref                         shift and go to state 60

state 42

    (38) varref -> ID arr_idx .

    COMMA           reduce using rule 38 (varref -> ID arr_idx .)
    SEMICOLON       reduce using rule 38 (varref -> ID arr_idx .)
    UNTIL           reduce using rule 38 (varref -> ID arr_idx .)
    ELSE            reduce using rule 38 (varref -> ID arr_idx .)
    ADD             reduce using rule 38 (varref -> ID arr_idx .)
    SUB             reduce using rule 38 (varref -> ID arr_idx .)
    MUL             reduce using rule 38 (varref -> ID arr_idx .)
    DIV             reduce using rule 38 (varref -> ID arr_idx .)
    RBRACK          reduce using rule 38 (varref -> ID arr_idx .)
    RPAR            reduce using rule 38 (varref -> ID arr_idx .)
    LT              reduce using rule 38 (varref -> ID arr_idx .)
    GT              reduce using rule 38 (varref -> ID arr_idx .)
    LEQ             reduce using rule 38 (varref -> ID arr_idx .)
    GEQ             reduce using rule 38 (varref -> ID arr_idx .)


state 43

    (44) expr_list -> expr_list COMMA . a_expr
    (27) a_expr -> . a_expr a_op a_expr
    (28) a_expr -> . varref
    (29) a_expr -> . INTEGER
    (30) a_expr -> . FLOAT
    (31) a_expr -> . LPAR a_expr RPAR
    (32) a_expr -> . SUB a_expr
    (33) a_expr -> . LITERAL_STR
    (38) varref -> . ID arr_idx

    INTEGER         shift and go to state 29
    FLOAT           shift and go to state 30
    LPAR            shift and go to state 31
    SUB             shift and go to state 32
    LITERAL_STR     shift and go to state 33
    ID              shift and go to state 25

    a_expr                         shift and go to state 61
    varref                         shift and go to state 28

state 44

    (27) a_expr -> a_expr a_op . a_expr
    (27) a_expr -> . a_expr a_op a_expr
    (28) a_expr -> . varref
    (29) a_expr -> . INTEGER
    (30) a_expr -> . FLOAT
    (31) a_expr -> . LPAR a_expr RPAR
    (32) a_expr -> . SUB a_expr
    (33) a_expr -> . LITERAL_STR
    (38) varref -> . ID arr_idx

    INTEGER         shift and go to state 29
    FLOAT           shift and go to state 30
    LPAR            shift and go to state 31
    SUB             shift and go to state 32
    LITERAL_STR     shift and go to state 33
    ID              shift and go to state 25

    a_expr                         shift and go to state 62
    varref                         shift and go to state 28

state 45

    (34) a_op -> ADD .

    INTEGER         reduce using rule 34 (a_op -> ADD .)
    FLOAT           reduce using rule 34 (a_op -> ADD .)
    LPAR            reduce using rule 34 (a_op -> ADD .)
    SUB             reduce using rule 34 (a_op -> ADD .)
    LITERAL_STR     reduce using rule 34 (a_op -> ADD .)
    ID              reduce using rule 34 (a_op -> ADD .)


state 46

    (35) a_op -> SUB .

    INTEGER         reduce using rule 35 (a_op -> SUB .)
    FLOAT           reduce using rule 35 (a_op -> SUB .)
    LPAR            reduce using rule 35 (a_op -> SUB .)
    SUB             reduce using rule 35 (a_op -> SUB .)
    LITERAL_STR     reduce using rule 35 (a_op -> SUB .)
    ID              reduce using rule 35 (a_op -> SUB .)


state 47

    (36) a_op -> MUL .

    INTEGER         reduce using rule 36 (a_op -> MUL .)
    FLOAT           reduce using rule 36 (a_op -> MUL .)
    LPAR            reduce using rule 36 (a_op -> MUL .)
    SUB             reduce using rule 36 (a_op -> MUL .)
    LITERAL_STR     reduce using rule 36 (a_op -> MUL .)
    ID              reduce using rule 36 (a_op -> MUL .)


state 48

    (37) a_op -> DIV .

    INTEGER         reduce using rule 37 (a_op -> DIV .)
    FLOAT           reduce using rule 37 (a_op -> DIV .)
    LPAR            reduce using rule 37 (a_op -> DIV .)
    SUB             reduce using rule 37 (a_op -> DIV .)
    LITERAL_STR     reduce using rule 37 (a_op -> DIV .)
    ID              reduce using rule 37 (a_op -> DIV .)


state 49

    (31) a_expr -> LPAR a_expr . RPAR
    (27) a_expr -> a_expr . a_op a_expr
    (34) a_op -> . ADD
    (35) a_op -> . SUB
    (36) a_op -> . MUL
    (37) a_op -> . DIV

    RPAR            shift and go to state 63
    ADD             shift and go to state 45
    SUB             shift and go to state 46
    MUL             shift and go to state 47
    DIV             shift and go to state 48

    a_op                           shift and go to state 44

state 50

    (32) a_expr -> SUB a_expr .
    (27) a_expr -> a_expr . a_op a_expr
    (34) a_op -> . ADD
    (35) a_op -> . SUB
    (36) a_op -> . MUL
    (37) a_op -> . DIV

  ! shift/reduce conflict for ADD resolved as shift
  ! shift/reduce conflict for SUB resolved as shift
  ! shift/reduce conflict for MUL resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
    COMMA           reduce using rule 32 (a_expr -> SUB a_expr .)
    SEMICOLON       reduce using rule 32 (a_expr -> SUB a_expr .)
    UNTIL           reduce using rule 32 (a_expr -> SUB a_expr .)
    ELSE            reduce using rule 32 (a_expr -> SUB a_expr .)
    RBRACK          reduce using rule 32 (a_expr -> SUB a_expr .)
    RPAR            reduce using rule 32 (a_expr -> SUB a_expr .)
    LT              reduce using rule 32 (a_expr -> SUB a_expr .)
    GT              reduce using rule 32 (a_expr -> SUB a_expr .)
    LEQ             reduce using rule 32 (a_expr -> SUB a_expr .)
    GEQ             reduce using rule 32 (a_expr -> SUB a_expr .)
    ADD             shift and go to state 45
    SUB             shift and go to state 46
    MUL             shift and go to state 47
    DIV             shift and go to state 48

  ! ADD             [ reduce using rule 32 (a_expr -> SUB a_expr .) ]
  ! SUB             [ reduce using rule 32 (a_expr -> SUB a_expr .) ]
  ! MUL             [ reduce using rule 32 (a_expr -> SUB a_expr .) ]
  ! DIV             [ reduce using rule 32 (a_expr -> SUB a_expr .) ]

    a_op                           shift and go to state 44

state 51

    (22) declaration -> datatype ID arr_size .

    SEMICOLON       reduce using rule 22 (declaration -> datatype ID arr_size .)
    UNTIL           reduce using rule 22 (declaration -> datatype ID arr_size .)
    ELSE            reduce using rule 22 (declaration -> datatype ID arr_size .)


state 52

    (23) arr_size -> LBRACK . a_expr RBRACK
    (27) a_expr -> . a_expr a_op a_expr
    (28) a_expr -> . varref
    (29) a_expr -> . INTEGER
    (30) a_expr -> . FLOAT
    (31) a_expr -> . LPAR a_expr RPAR
    (32) a_expr -> . SUB a_expr
    (33) a_expr -> . LITERAL_STR
    (38) varref -> . ID arr_idx

    INTEGER         shift and go to state 29
    FLOAT           shift and go to state 30
    LPAR            shift and go to state 31
    SUB             shift and go to state 32
    LITERAL_STR     shift and go to state 33
    ID              shift and go to state 25

    a_expr                         shift and go to state 64
    varref                         shift and go to state 28

state 53

    (11) construct_while -> WHILE LPAR l_expr . RPAR DO stmt

    RPAR            shift and go to state 65


state 54

    (16) l_expr -> a_expr . oprel a_expr
    (27) a_expr -> a_expr . a_op a_expr
    (17) oprel -> . LT
    (18) oprel -> . GT
    (19) oprel -> . LEQ
    (20) oprel -> . GEQ
    (34) a_op -> . ADD
    (35) a_op -> . SUB
    (36) a_op -> . MUL
    (37) a_op -> . DIV

    LT              shift and go to state 67
    GT              shift and go to state 68
    LEQ             shift and go to state 69
    GEQ             shift and go to state 70
    ADD             shift and go to state 45
    SUB             shift and go to state 46
    MUL             shift and go to state 47
    DIV             shift and go to state 48

    oprel                          shift and go to state 66
    a_op                           shift and go to state 44

state 55

    (12) construct_repeat -> REPEAT stmt_list UNTIL . LPAR l_expr RPAR

    LPAR            shift and go to state 71


state 56

    (2) stmt_list -> stmt_list SEMICOLON . stmt
    (4) stmt -> . assignment
    (5) stmt -> . read
    (6) stmt -> . write
    (7) stmt -> . declaration
    (8) stmt -> . construct_while
    (9) stmt -> . construct_repeat
    (10) stmt -> . construct_if
    (21) assignment -> . ID arr_idx ASSIGN a_expr
    (40) read -> . READ varlist
    (41) write -> . WRITE expr_list
    (22) declaration -> . datatype ID arr_size
    (11) construct_while -> . WHILE LPAR l_expr RPAR DO stmt
    (12) construct_repeat -> . REPEAT stmt_list UNTIL LPAR l_expr RPAR
    (13) construct_if -> . IF LPAR l_expr RPAR stmt construct_else
    (25) datatype -> . DT_INT
    (26) datatype -> . DT_FLOAT

    ID              shift and go to state 11
    READ            shift and go to state 12
    WRITE           shift and go to state 13
    WHILE           shift and go to state 15
    REPEAT          shift and go to state 16
    IF              shift and go to state 17
    DT_INT          shift and go to state 18
    DT_FLOAT        shift and go to state 19

    stmt                           shift and go to state 38
    assignment                     shift and go to state 4
    read                           shift and go to state 5
    write                          shift and go to state 6
    declaration                    shift and go to state 7
    construct_while                shift and go to state 8
    construct_repeat               shift and go to state 9
    construct_if                   shift and go to state 10
    datatype                       shift and go to state 14

state 57

    (13) construct_if -> IF LPAR l_expr . RPAR stmt construct_else

    RPAR            shift and go to state 72


state 58

    (21) assignment -> ID arr_idx ASSIGN a_expr .
    (27) a_expr -> a_expr . a_op a_expr
    (34) a_op -> . ADD
    (35) a_op -> . SUB
    (36) a_op -> . MUL
    (37) a_op -> . DIV

    SEMICOLON       reduce using rule 21 (assignment -> ID arr_idx ASSIGN a_expr .)
    UNTIL           reduce using rule 21 (assignment -> ID arr_idx ASSIGN a_expr .)
    ELSE            reduce using rule 21 (assignment -> ID arr_idx ASSIGN a_expr .)
    ADD             shift and go to state 45
    SUB             shift and go to state 46
    MUL             shift and go to state 47
    DIV             shift and go to state 48

    a_op                           shift and go to state 44

state 59

    (39) arr_idx -> LBRACK a_expr RBRACK .

    ASSIGN          reduce using rule 39 (arr_idx -> LBRACK a_expr RBRACK .)
    COMMA           reduce using rule 39 (arr_idx -> LBRACK a_expr RBRACK .)
    SEMICOLON       reduce using rule 39 (arr_idx -> LBRACK a_expr RBRACK .)
    UNTIL           reduce using rule 39 (arr_idx -> LBRACK a_expr RBRACK .)
    ELSE            reduce using rule 39 (arr_idx -> LBRACK a_expr RBRACK .)
    ADD             reduce using rule 39 (arr_idx -> LBRACK a_expr RBRACK .)
    SUB             reduce using rule 39 (arr_idx -> LBRACK a_expr RBRACK .)
    MUL             reduce using rule 39 (arr_idx -> LBRACK a_expr RBRACK .)
    DIV             reduce using rule 39 (arr_idx -> LBRACK a_expr RBRACK .)
    RBRACK          reduce using rule 39 (arr_idx -> LBRACK a_expr RBRACK .)
    RPAR            reduce using rule 39 (arr_idx -> LBRACK a_expr RBRACK .)
    LT              reduce using rule 39 (arr_idx -> LBRACK a_expr RBRACK .)
    GT              reduce using rule 39 (arr_idx -> LBRACK a_expr RBRACK .)
    LEQ             reduce using rule 39 (arr_idx -> LBRACK a_expr RBRACK .)
    GEQ             reduce using rule 39 (arr_idx -> LBRACK a_expr RBRACK .)


state 60

    (42) varlist -> varlist COMMA varref .

    COMMA           reduce using rule 42 (varlist -> varlist COMMA varref .)
    SEMICOLON       reduce using rule 42 (varlist -> varlist COMMA varref .)
    UNTIL           reduce using rule 42 (varlist -> varlist COMMA varref .)
    ELSE            reduce using rule 42 (varlist -> varlist COMMA varref .)


state 61

    (44) expr_list -> expr_list COMMA a_expr .
    (27) a_expr -> a_expr . a_op a_expr
    (34) a_op -> . ADD
    (35) a_op -> . SUB
    (36) a_op -> . MUL
    (37) a_op -> . DIV

    COMMA           reduce using rule 44 (expr_list -> expr_list COMMA a_expr .)
    SEMICOLON       reduce using rule 44 (expr_list -> expr_list COMMA a_expr .)
    UNTIL           reduce using rule 44 (expr_list -> expr_list COMMA a_expr .)
    ELSE            reduce using rule 44 (expr_list -> expr_list COMMA a_expr .)
    ADD             shift and go to state 45
    SUB             shift and go to state 46
    MUL             shift and go to state 47
    DIV             shift and go to state 48

    a_op                           shift and go to state 44

state 62

    (27) a_expr -> a_expr a_op a_expr .
    (27) a_expr -> a_expr . a_op a_expr
    (34) a_op -> . ADD
    (35) a_op -> . SUB
    (36) a_op -> . MUL
    (37) a_op -> . DIV

  ! shift/reduce conflict for ADD resolved as shift
  ! shift/reduce conflict for SUB resolved as shift
  ! shift/reduce conflict for MUL resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
    COMMA           reduce using rule 27 (a_expr -> a_expr a_op a_expr .)
    SEMICOLON       reduce using rule 27 (a_expr -> a_expr a_op a_expr .)
    UNTIL           reduce using rule 27 (a_expr -> a_expr a_op a_expr .)
    ELSE            reduce using rule 27 (a_expr -> a_expr a_op a_expr .)
    RBRACK          reduce using rule 27 (a_expr -> a_expr a_op a_expr .)
    RPAR            reduce using rule 27 (a_expr -> a_expr a_op a_expr .)
    LT              reduce using rule 27 (a_expr -> a_expr a_op a_expr .)
    GT              reduce using rule 27 (a_expr -> a_expr a_op a_expr .)
    LEQ             reduce using rule 27 (a_expr -> a_expr a_op a_expr .)
    GEQ             reduce using rule 27 (a_expr -> a_expr a_op a_expr .)
    ADD             shift and go to state 45
    SUB             shift and go to state 46
    MUL             shift and go to state 47
    DIV             shift and go to state 48

  ! ADD             [ reduce using rule 27 (a_expr -> a_expr a_op a_expr .) ]
  ! SUB             [ reduce using rule 27 (a_expr -> a_expr a_op a_expr .) ]
  ! MUL             [ reduce using rule 27 (a_expr -> a_expr a_op a_expr .) ]
  ! DIV             [ reduce using rule 27 (a_expr -> a_expr a_op a_expr .) ]

    a_op                           shift and go to state 44

state 63

    (31) a_expr -> LPAR a_expr RPAR .

    ADD             reduce using rule 31 (a_expr -> LPAR a_expr RPAR .)
    SUB             reduce using rule 31 (a_expr -> LPAR a_expr RPAR .)
    MUL             reduce using rule 31 (a_expr -> LPAR a_expr RPAR .)
    DIV             reduce using rule 31 (a_expr -> LPAR a_expr RPAR .)
    COMMA           reduce using rule 31 (a_expr -> LPAR a_expr RPAR .)
    SEMICOLON       reduce using rule 31 (a_expr -> LPAR a_expr RPAR .)
    UNTIL           reduce using rule 31 (a_expr -> LPAR a_expr RPAR .)
    ELSE            reduce using rule 31 (a_expr -> LPAR a_expr RPAR .)
    RBRACK          reduce using rule 31 (a_expr -> LPAR a_expr RPAR .)
    RPAR            reduce using rule 31 (a_expr -> LPAR a_expr RPAR .)
    LT              reduce using rule 31 (a_expr -> LPAR a_expr RPAR .)
    GT              reduce using rule 31 (a_expr -> LPAR a_expr RPAR .)
    LEQ             reduce using rule 31 (a_expr -> LPAR a_expr RPAR .)
    GEQ             reduce using rule 31 (a_expr -> LPAR a_expr RPAR .)


state 64

    (23) arr_size -> LBRACK a_expr . RBRACK
    (27) a_expr -> a_expr . a_op a_expr
    (34) a_op -> . ADD
    (35) a_op -> . SUB
    (36) a_op -> . MUL
    (37) a_op -> . DIV

    RBRACK          shift and go to state 73
    ADD             shift and go to state 45
    SUB             shift and go to state 46
    MUL             shift and go to state 47
    DIV             shift and go to state 48

    a_op                           shift and go to state 44

state 65

    (11) construct_while -> WHILE LPAR l_expr RPAR . DO stmt

    DO              shift and go to state 74


state 66

    (16) l_expr -> a_expr oprel . a_expr
    (27) a_expr -> . a_expr a_op a_expr
    (28) a_expr -> . varref
    (29) a_expr -> . INTEGER
    (30) a_expr -> . FLOAT
    (31) a_expr -> . LPAR a_expr RPAR
    (32) a_expr -> . SUB a_expr
    (33) a_expr -> . LITERAL_STR
    (38) varref -> . ID arr_idx

    INTEGER         shift and go to state 29
    FLOAT           shift and go to state 30
    LPAR            shift and go to state 31
    SUB             shift and go to state 32
    LITERAL_STR     shift and go to state 33
    ID              shift and go to state 25

    a_expr                         shift and go to state 75
    varref                         shift and go to state 28

state 67

    (17) oprel -> LT .

    INTEGER         reduce using rule 17 (oprel -> LT .)
    FLOAT           reduce using rule 17 (oprel -> LT .)
    LPAR            reduce using rule 17 (oprel -> LT .)
    SUB             reduce using rule 17 (oprel -> LT .)
    LITERAL_STR     reduce using rule 17 (oprel -> LT .)
    ID              reduce using rule 17 (oprel -> LT .)


state 68

    (18) oprel -> GT .

    INTEGER         reduce using rule 18 (oprel -> GT .)
    FLOAT           reduce using rule 18 (oprel -> GT .)
    LPAR            reduce using rule 18 (oprel -> GT .)
    SUB             reduce using rule 18 (oprel -> GT .)
    LITERAL_STR     reduce using rule 18 (oprel -> GT .)
    ID              reduce using rule 18 (oprel -> GT .)


state 69

    (19) oprel -> LEQ .

    INTEGER         reduce using rule 19 (oprel -> LEQ .)
    FLOAT           reduce using rule 19 (oprel -> LEQ .)
    LPAR            reduce using rule 19 (oprel -> LEQ .)
    SUB             reduce using rule 19 (oprel -> LEQ .)
    LITERAL_STR     reduce using rule 19 (oprel -> LEQ .)
    ID              reduce using rule 19 (oprel -> LEQ .)


state 70

    (20) oprel -> GEQ .

    INTEGER         reduce using rule 20 (oprel -> GEQ .)
    FLOAT           reduce using rule 20 (oprel -> GEQ .)
    LPAR            reduce using rule 20 (oprel -> GEQ .)
    SUB             reduce using rule 20 (oprel -> GEQ .)
    LITERAL_STR     reduce using rule 20 (oprel -> GEQ .)
    ID              reduce using rule 20 (oprel -> GEQ .)


state 71

    (12) construct_repeat -> REPEAT stmt_list UNTIL LPAR . l_expr RPAR
    (16) l_expr -> . a_expr oprel a_expr
    (27) a_expr -> . a_expr a_op a_expr
    (28) a_expr -> . varref
    (29) a_expr -> . INTEGER
    (30) a_expr -> . FLOAT
    (31) a_expr -> . LPAR a_expr RPAR
    (32) a_expr -> . SUB a_expr
    (33) a_expr -> . LITERAL_STR
    (38) varref -> . ID arr_idx

    INTEGER         shift and go to state 29
    FLOAT           shift and go to state 30
    LPAR            shift and go to state 31
    SUB             shift and go to state 32
    LITERAL_STR     shift and go to state 33
    ID              shift and go to state 25

    l_expr                         shift and go to state 76
    a_expr                         shift and go to state 54
    varref                         shift and go to state 28

state 72

    (13) construct_if -> IF LPAR l_expr RPAR . stmt construct_else
    (4) stmt -> . assignment
    (5) stmt -> . read
    (6) stmt -> . write
    (7) stmt -> . declaration
    (8) stmt -> . construct_while
    (9) stmt -> . construct_repeat
    (10) stmt -> . construct_if
    (21) assignment -> . ID arr_idx ASSIGN a_expr
    (40) read -> . READ varlist
    (41) write -> . WRITE expr_list
    (22) declaration -> . datatype ID arr_size
    (11) construct_while -> . WHILE LPAR l_expr RPAR DO stmt
    (12) construct_repeat -> . REPEAT stmt_list UNTIL LPAR l_expr RPAR
    (13) construct_if -> . IF LPAR l_expr RPAR stmt construct_else
    (25) datatype -> . DT_INT
    (26) datatype -> . DT_FLOAT

    ID              shift and go to state 11
    READ            shift and go to state 12
    WRITE           shift and go to state 13
    WHILE           shift and go to state 15
    REPEAT          shift and go to state 16
    IF              shift and go to state 17
    DT_INT          shift and go to state 18
    DT_FLOAT        shift and go to state 19

    stmt                           shift and go to state 77
    assignment                     shift and go to state 4
    read                           shift and go to state 5
    write                          shift and go to state 6
    declaration                    shift and go to state 7
    construct_while                shift and go to state 8
    construct_repeat               shift and go to state 9
    construct_if                   shift and go to state 10
    datatype                       shift and go to state 14

state 73

    (23) arr_size -> LBRACK a_expr RBRACK .

    SEMICOLON       reduce using rule 23 (arr_size -> LBRACK a_expr RBRACK .)
    UNTIL           reduce using rule 23 (arr_size -> LBRACK a_expr RBRACK .)
    ELSE            reduce using rule 23 (arr_size -> LBRACK a_expr RBRACK .)


state 74

    (11) construct_while -> WHILE LPAR l_expr RPAR DO . stmt
    (4) stmt -> . assignment
    (5) stmt -> . read
    (6) stmt -> . write
    (7) stmt -> . declaration
    (8) stmt -> . construct_while
    (9) stmt -> . construct_repeat
    (10) stmt -> . construct_if
    (21) assignment -> . ID arr_idx ASSIGN a_expr
    (40) read -> . READ varlist
    (41) write -> . WRITE expr_list
    (22) declaration -> . datatype ID arr_size
    (11) construct_while -> . WHILE LPAR l_expr RPAR DO stmt
    (12) construct_repeat -> . REPEAT stmt_list UNTIL LPAR l_expr RPAR
    (13) construct_if -> . IF LPAR l_expr RPAR stmt construct_else
    (25) datatype -> . DT_INT
    (26) datatype -> . DT_FLOAT

    ID              shift and go to state 11
    READ            shift and go to state 12
    WRITE           shift and go to state 13
    WHILE           shift and go to state 15
    REPEAT          shift and go to state 16
    IF              shift and go to state 17
    DT_INT          shift and go to state 18
    DT_FLOAT        shift and go to state 19

    stmt                           shift and go to state 78
    assignment                     shift and go to state 4
    read                           shift and go to state 5
    write                          shift and go to state 6
    declaration                    shift and go to state 7
    construct_while                shift and go to state 8
    construct_repeat               shift and go to state 9
    construct_if                   shift and go to state 10
    datatype                       shift and go to state 14

state 75

    (16) l_expr -> a_expr oprel a_expr .
    (27) a_expr -> a_expr . a_op a_expr
    (34) a_op -> . ADD
    (35) a_op -> . SUB
    (36) a_op -> . MUL
    (37) a_op -> . DIV

    RPAR            reduce using rule 16 (l_expr -> a_expr oprel a_expr .)
    ADD             shift and go to state 45
    SUB             shift and go to state 46
    MUL             shift and go to state 47
    DIV             shift and go to state 48

    a_op                           shift and go to state 44

state 76

    (12) construct_repeat -> REPEAT stmt_list UNTIL LPAR l_expr . RPAR

    RPAR            shift and go to state 79


state 77

    (13) construct_if -> IF LPAR l_expr RPAR stmt . construct_else
    (14) construct_else -> .
    (15) construct_else -> . ELSE stmt

  ! shift/reduce conflict for ELSE resolved as shift
    SEMICOLON       reduce using rule 14 (construct_else -> .)
    UNTIL           reduce using rule 14 (construct_else -> .)
    ELSE            shift and go to state 81

  ! ELSE            [ reduce using rule 14 (construct_else -> .) ]

    construct_else                 shift and go to state 80

state 78

    (11) construct_while -> WHILE LPAR l_expr RPAR DO stmt .

    SEMICOLON       reduce using rule 11 (construct_while -> WHILE LPAR l_expr RPAR DO stmt .)
    UNTIL           reduce using rule 11 (construct_while -> WHILE LPAR l_expr RPAR DO stmt .)
    ELSE            reduce using rule 11 (construct_while -> WHILE LPAR l_expr RPAR DO stmt .)


state 79

    (12) construct_repeat -> REPEAT stmt_list UNTIL LPAR l_expr RPAR .

    SEMICOLON       reduce using rule 12 (construct_repeat -> REPEAT stmt_list UNTIL LPAR l_expr RPAR .)
    UNTIL           reduce using rule 12 (construct_repeat -> REPEAT stmt_list UNTIL LPAR l_expr RPAR .)
    ELSE            reduce using rule 12 (construct_repeat -> REPEAT stmt_list UNTIL LPAR l_expr RPAR .)


state 80

    (13) construct_if -> IF LPAR l_expr RPAR stmt construct_else .

    SEMICOLON       reduce using rule 13 (construct_if -> IF LPAR l_expr RPAR stmt construct_else .)
    UNTIL           reduce using rule 13 (construct_if -> IF LPAR l_expr RPAR stmt construct_else .)
    ELSE            reduce using rule 13 (construct_if -> IF LPAR l_expr RPAR stmt construct_else .)


state 81

    (15) construct_else -> ELSE . stmt
    (4) stmt -> . assignment
    (5) stmt -> . read
    (6) stmt -> . write
    (7) stmt -> . declaration
    (8) stmt -> . construct_while
    (9) stmt -> . construct_repeat
    (10) stmt -> . construct_if
    (21) assignment -> . ID arr_idx ASSIGN a_expr
    (40) read -> . READ varlist
    (41) write -> . WRITE expr_list
    (22) declaration -> . datatype ID arr_size
    (11) construct_while -> . WHILE LPAR l_expr RPAR DO stmt
    (12) construct_repeat -> . REPEAT stmt_list UNTIL LPAR l_expr RPAR
    (13) construct_if -> . IF LPAR l_expr RPAR stmt construct_else
    (25) datatype -> . DT_INT
    (26) datatype -> . DT_FLOAT

    ID              shift and go to state 11
    READ            shift and go to state 12
    WRITE           shift and go to state 13
    WHILE           shift and go to state 15
    REPEAT          shift and go to state 16
    IF              shift and go to state 17
    DT_INT          shift and go to state 18
    DT_FLOAT        shift and go to state 19

    stmt                           shift and go to state 82
    assignment                     shift and go to state 4
    read                           shift and go to state 5
    write                          shift and go to state 6
    declaration                    shift and go to state 7
    construct_while                shift and go to state 8
    construct_repeat               shift and go to state 9
    construct_if                   shift and go to state 10
    datatype                       shift and go to state 14

state 82

    (15) construct_else -> ELSE stmt .

    ELSE            reduce using rule 15 (construct_else -> ELSE stmt .)
    SEMICOLON       reduce using rule 15 (construct_else -> ELSE stmt .)
    UNTIL           reduce using rule 15 (construct_else -> ELSE stmt .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ADD in state 50 resolved as shift
WARNING: shift/reduce conflict for SUB in state 50 resolved as shift
WARNING: shift/reduce conflict for MUL in state 50 resolved as shift
WARNING: shift/reduce conflict for DIV in state 50 resolved as shift
WARNING: shift/reduce conflict for ADD in state 62 resolved as shift
WARNING: shift/reduce conflict for SUB in state 62 resolved as shift
WARNING: shift/reduce conflict for MUL in state 62 resolved as shift
WARNING: shift/reduce conflict for DIV in state 62 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 77 resolved as shift
